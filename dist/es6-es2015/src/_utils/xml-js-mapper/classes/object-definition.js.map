{"version":3,"file":"object-definition.js","sourceRoot":"","sources":["../../../../../../src/_utils/xml-js-mapper/classes/object-definition.ts"],"names":[],"mappings":"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","sourcesContent":["import { FunctionType, IXmlNamespaces } from \"../types\"; // IXmlValueObject\r\nimport { PropertyDefinition } from \"./property-definition\";\r\n\r\nexport class ObjectDefinition {\r\n    public ctr: () => void;\r\n    public beforeDeserialized: () => void;\r\n    public onDeserialized: () => void;\r\n    public discriminatorProperty: string;\r\n    public discriminatorValue: any;\r\n    public properties: Map<string, PropertyDefinition>;\r\n    public namespaces: IXmlNamespaces | undefined;\r\n\r\n    constructor() {\r\n        this.ctr = () => undefined;\r\n        this.beforeDeserialized = () => undefined;\r\n        this.onDeserialized = () => undefined;\r\n        this.properties = new Map<string, PropertyDefinition>();\r\n    }\r\n\r\n    public getProperty(key: string) {\r\n        let property = this.properties.get(key);\r\n        if (!property) {\r\n            property = new PropertyDefinition();\r\n            this.properties.set(key, property);\r\n        }\r\n        return property;\r\n    }\r\n}\r\n\r\nexport const objectDefinitions: Map<FunctionType, ObjectDefinition> = new Map<FunctionType, ObjectDefinition>();\r\n\r\nexport function getDefinition(objectType: FunctionType): ObjectDefinition {\r\n\r\n    let definition = objectDefinitions.get(objectType);\r\n    if (!definition) {\r\n        definition = new ObjectDefinition();\r\n        objectDefinitions.set(objectType, definition);\r\n    }\r\n    return definition;\r\n}\r\n\r\nexport function getInheritanceChain(objectType: object): FunctionType[] {\r\n    if (!objectType) {\r\n        return [];\r\n    }\r\n    const parent = Object.getPrototypeOf(objectType);\r\n    return [objectType.constructor].concat(getInheritanceChain(parent));\r\n}\r\n\r\ninterface IFunctionTypeAndObjectDefinition {\r\n    functionType: FunctionType;\r\n    objectDefinition: ObjectDefinition;\r\n}\r\n\r\nfunction getChildObjectTypeDefinitions(parentObjectType: FunctionType): IFunctionTypeAndObjectDefinition[] {\r\n    const childDefs: IFunctionTypeAndObjectDefinition[] = [];\r\n\r\n    objectDefinitions.forEach((def, objectType) => {\r\n        const superObjectType = Object.getPrototypeOf(objectType.prototype).constructor;\r\n\r\n        if (superObjectType === parentObjectType) {\r\n            childDefs.push({ functionType: objectType, objectDefinition: def });\r\n        }\r\n    });\r\n\r\n    return childDefs;\r\n}\r\n\r\nexport function getTypedInheritanceChain(\r\n    objectType: FunctionType,\r\n    objectInstance?: Node, // IXmlValueObject\r\n): FunctionType[] {\r\n\r\n    const parentDef = objectDefinitions.get(objectType);\r\n\r\n    let childDefs: IFunctionTypeAndObjectDefinition[] = [];\r\n\r\n    if (objectInstance && parentDef && parentDef.discriminatorProperty) {\r\n        childDefs = childDefs.concat(getChildObjectTypeDefinitions(objectType));\r\n    }\r\n\r\n    let actualObjectType: FunctionType | undefined;\r\n\r\n    while (childDefs.length !== 0 && !actualObjectType) {\r\n        const ifo = childDefs.shift();\r\n        const objectType2 = ifo ? ifo.functionType : undefined;\r\n        const def = ifo ? ifo.objectDefinition : undefined;\r\n\r\n        if (def && def.hasOwnProperty(\"discriminatorValue\")) {\r\n            if (objectInstance\r\n                && parentDef\r\n                && def.discriminatorValue === (objectInstance as any)[parentDef.discriminatorProperty]) {\r\n                if (def.hasOwnProperty(\"discriminatorProperty\")) {\r\n                    return getTypedInheritanceChain(objectType2, objectInstance);\r\n                }\r\n                actualObjectType = objectType2;\r\n            }\r\n        } else {\r\n            childDefs = childDefs.concat(getChildObjectTypeDefinitions(objectType2));\r\n        }\r\n    }\r\n\r\n    if (!actualObjectType) {\r\n        actualObjectType = objectType;\r\n    }\r\n\r\n    const inheritanceChain = new Set<FunctionType>(getInheritanceChain(Object.create(actualObjectType.prototype)));\r\n    return Array.from(inheritanceChain).filter((t) => objectDefinitions.has(t));\r\n}\r\n"]}