{"version":3,"file":"transformer-lcp-alt.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp-alt.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transform } from \"stream\";\r\n\r\nimport { Publication } from \"@models/publication\";\r\nimport { Link } from \"@models/publication-link\";\r\nimport { IStreamAndLength } from \"@utils/zip/zip\";\r\nimport * as debug_ from \"debug\";\r\nimport * as forge from \"node-forge\";\r\n\r\nimport { ICryptoInfo, TransformerLCP } from \"./transformer-lcp\";\r\n\r\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\r\n\r\n// import * as forge from \"node-forge\";\r\n// import { streamToBufferPromise } from \"@utils/stream/BufferUtils\";\r\n// import { RangeStream } from \"@utils/stream/RangeStream\";\r\n// import { ITransformer } from \"./transformer\";\r\n\r\nconst debug = debug_(\"r2:transformer:lcp\");\r\nconst debugx = debug_(\"r2:transformer:stream:lcp\");\r\n\r\nconst AES_BLOCK_SIZE = 16;\r\n\r\n// let streamCounter = 0;\r\n\r\nexport class TransformerLCPAlt extends TransformerLCP {\r\n\r\n    public async transformStream(\r\n        publication: Publication,\r\n        link: Link,\r\n        stream: IStreamAndLength,\r\n        isPartialByteRangeRequest: boolean,\r\n        partialByteBegin: number,\r\n        partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n        let cryptoInfo: ICryptoInfo | undefined;\r\n        let plainTextSize = -1;\r\n        let cypherBlockPadding = -1;\r\n        if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n            plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n            cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\r\n        } else {\r\n            // const timeBegin = process.hrtime();\r\n\r\n            cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\r\n            plainTextSize = cryptoInfo.length;\r\n            cypherBlockPadding = cryptoInfo.padding;\r\n\r\n            // length cached to avoid resetting the stream to zero-position\r\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n            link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\r\n\r\n            stream = await stream.reset();\r\n\r\n            // const timeElapsed = process.hrtime(timeBegin);\r\n            // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\r\n            //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\r\n\r\n            // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\r\n\r\n            if (link.Properties.Encrypted.OriginalLength &&\r\n                link.Properties.Encrypted.Compression === \"none\" &&\r\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\r\n\r\n                debug(`############### ` +\r\n                    `LCP transformStream() LENGTH NOT MATCH ` +\r\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize:` +\r\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\r\n            }\r\n        }\r\n\r\n        if (partialByteBegin < 0) {\r\n            partialByteBegin = 0;\r\n        }\r\n\r\n        if (partialByteEnd < 0) {\r\n            partialByteEnd = plainTextSize - 1;\r\n            if (link.Properties.Encrypted.OriginalLength) {\r\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\r\n            }\r\n        }\r\n\r\n        const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\r\n\r\n        // block padding scheme\r\n        let padding = false; // NO_PADDING\r\n        const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\r\n\r\n        // debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\r\n\r\n        if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\r\n            padding = true; // W3C_PADDING, also PKCS#7\r\n        }\r\n\r\n        // byte offset in first block of the cypher text that contains the range begin\r\n        const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\r\n\r\n        // we read the entire first block, even if partially used\r\n        const readPosition = partialByteBegin - blockOffset;\r\n\r\n        // debug(\"LCP transformStream() blockOffset: \" + blockOffset);\r\n        // debug(\"LCP transformStream() readPosition: \" + readPosition);\r\n\r\n        // number of blocks to read\r\n        let blocksCount = 1;\r\n        let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\r\n\r\n        // debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\r\n\r\n        if (partialByteLength < bytesInFirstBlock) {\r\n            bytesInFirstBlock = 0;\r\n        }\r\n        if (bytesInFirstBlock > 0) {\r\n            blocksCount++;\r\n        }\r\n\r\n        const diff = partialByteLength - bytesInFirstBlock;\r\n\r\n        // debug(\"LCP transformStream() diff: \" + diff);\r\n\r\n        let inc = diff / AES_BLOCK_SIZE;\r\n        // debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n        inc = Math.floor(inc);\r\n        // debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n        blocksCount += inc;\r\n\r\n        const rem = diff % AES_BLOCK_SIZE;\r\n        // debug(\"LCP transformStream() rem: \" + rem);\r\n\r\n        if (rem !== 0) {\r\n            blocksCount++;\r\n        }\r\n\r\n        // debug(\"LCP transformStream() blocksCount: \" + blocksCount);\r\n\r\n        // number of bytes to read (block aligned)\r\n        const toRead = blocksCount * AES_BLOCK_SIZE;\r\n\r\n        const readPositionEND = readPosition + toRead - 1;\r\n\r\n        // const rangeStream = new RangeStream(readPosition, readPositionEND, stream.length);\r\n        const decryptStreamStreamBegin = readPosition;\r\n        const decryptStreamStreamEnd = readPositionEND;\r\n\r\n        const decryptStreamBlockOffset = blockOffset;\r\n\r\n        let decryptStreamBytesReceived = 0;\r\n        let decryptStreamBytesSent = 0;\r\n        let decryptStreamFinished = false;\r\n        let decryptStreamClosed = false;\r\n        let decryptStreamFirst = true;\r\n\r\n        const decryptStreamThis = this;\r\n\r\n        let decryptStreamBuffers: Buffer[] = [];\r\n\r\n        const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\r\n\r\n        // @ts-ignore: TS2345 strictFunctionTypes\r\n        const decryptStream = new Transform({\r\n            flush(callback: () => void): void {\r\n                debugx(\"LcpDecryptStream FLUSH\");\r\n\r\n                let toDecrypt: Buffer | undefined;\r\n\r\n                let decryptStreamBuffersTotalLength = 0;\r\n                decryptStreamBuffers.forEach((buff) => {\r\n                    decryptStreamBuffersTotalLength += buff.length;\r\n                });\r\n                if (decryptStreamBuffersTotalLength) {\r\n\r\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBuffersTotalLength: \" +\r\n                        decryptStreamBuffersTotalLength);\r\n\r\n                    const available = decryptStreamBuffersTotalLength;\r\n\r\n                    if (available === TWO_AES_BLOCK_SIZE) {\r\n                        toDecrypt = Buffer.concat(decryptStreamBuffers);\r\n                        decryptStreamBuffers = [];\r\n                    } else if (available < TWO_AES_BLOCK_SIZE) {\r\n                        debugx(\"LcpDecryptStream NOT ENOUGH DATA????\");\r\n                    } else { // available > TWO_AES_BLOCK_SIZE\r\n\r\n                        const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\r\n                        decryptStreamBuffers = [];\r\n\r\n                        const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\r\n                        const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                        // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\r\n                        if (blocksBytes === decryptStreamBuffersConcat.length) {\r\n                            toDecrypt = decryptStreamBuffersConcat;\r\n                        } else {\r\n                            debugx(\"LcpDecryptStream OVERFLOW DATA????\");\r\n                            // toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\r\n                            // decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (toDecrypt) {\r\n                    let newBuff = decryptStreamThis.innerDecrypt(\r\n                        publication,\r\n                        link,\r\n                        toDecrypt,\r\n                        padding);\r\n                    if (decryptStreamFirst) {\r\n                        decryptStreamFirst = false;\r\n                        newBuff = newBuff.slice(decryptStreamBlockOffset);\r\n                    }\r\n                    decryptStreamBytesSent += newBuff.length;\r\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBytesSent: \" + decryptStreamBytesSent);\r\n                    decryptStream.push(newBuff);\r\n                }\r\n\r\n                if (decryptStreamBytesSent !== plainTextSize) {\r\n\r\n                    debugx(`############### ` +\r\n                        `LcpDecryptStream FLUSH  LENGTH NOT MATCH ` +\r\n                        `decryptStreamBytesSent !== plainTextSize:` +\r\n                        `[ ${decryptStreamStreamBegin} (${decryptStreamStreamEnd}) ] ` +\r\n                        `${decryptStreamBytesReceived} (${stream.length}) > ` +\r\n                        `${decryptStreamBytesSent} !== ${plainTextSize}`);\r\n                }\r\n                callback();\r\n            },\r\n\r\n            transform(chunk: Buffer, _encoding: string, callback: () => void): void {\r\n                decryptStreamBytesReceived += chunk.length;\r\n\r\n                debugx(\"TRANSFORM chunk.length: \" + chunk.length + \" (( \" + decryptStreamBytesReceived);\r\n\r\n                if (decryptStreamFinished) {\r\n                    if (!decryptStreamClosed) {\r\n                        debugx(\"???? LcpDecryptStream CLOSING...\");\r\n                        decryptStreamClosed = true;\r\n                        decryptStream.push(null);\r\n                    } else {\r\n                        debugx(\"???? LcpDecryptStream STILL PIPE CALLING _transform ??!\");\r\n                        decryptStream.end();\r\n                    }\r\n                } else {\r\n                    if (decryptStreamBytesReceived > decryptStreamStreamBegin) {\r\n\r\n                        let chunkBegin = 0;\r\n                        let chunkEnd = chunk.length - 1;\r\n\r\n                        chunkBegin = decryptStreamStreamBegin - (decryptStreamBytesReceived - chunk.length);\r\n                        if (chunkBegin < 0) {\r\n                            chunkBegin = 0;\r\n                        }\r\n\r\n                        if (decryptStreamBytesReceived > decryptStreamStreamEnd) {\r\n                            decryptStreamFinished = true;\r\n\r\n                            const decr = decryptStreamBytesReceived - decryptStreamStreamEnd;\r\n\r\n                            debugx(\"LcpDecryptStream TRANSFORM FINISH decr: \" + decr);\r\n\r\n                            chunkEnd = chunk.length - decr;\r\n                        }\r\n\r\n                        debugx(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\r\n\r\n                        const encryptedChunk = chunk.slice(chunkBegin, chunkEnd + 1);\r\n\r\n                        let toDecrypt: Buffer | undefined;\r\n\r\n                        let decryptStreamBuffersTotalLength = 0;\r\n                        decryptStreamBuffers.forEach((buff) => {\r\n                            decryptStreamBuffersTotalLength += buff.length;\r\n                        });\r\n                        if (decryptStreamBuffersTotalLength) {\r\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBuffersTotalLength: \" +\r\n                                decryptStreamBuffersTotalLength);\r\n\r\n                            const available = decryptStreamBuffersTotalLength + encryptedChunk.length;\r\n\r\n                            if (available === TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                                toDecrypt = Buffer.concat(decryptStreamBuffers);\r\n                                decryptStreamBuffers = [];\r\n                            } else if (available < TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                            } else { // available > TWO_AES_BLOCK_SIZE\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                                const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\r\n                                decryptStreamBuffers = [];\r\n\r\n                                const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\r\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                                // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\r\n                                if (blocksBytes === decryptStreamBuffersConcat.length) {\r\n                                    toDecrypt = decryptStreamBuffersConcat;\r\n                                } else {\r\n                                    toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\r\n                                    decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (encryptedChunk.length === TWO_AES_BLOCK_SIZE) {\r\n                                toDecrypt = encryptedChunk;\r\n                            } else if (encryptedChunk.length < TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                            } else { // encryptedChunk.length > TWO_AES_BLOCK_SIZE\r\n                                const nBlocks = Math.floor(encryptedChunk.length / AES_BLOCK_SIZE);\r\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                                // encryptedChunk.length % AES_BLOCK_SIZE === 0\r\n                                if (blocksBytes === encryptedChunk.length) {\r\n                                    toDecrypt = encryptedChunk;\r\n                                } else {\r\n                                    toDecrypt = encryptedChunk.slice(0, blocksBytes);\r\n                                    decryptStreamBuffers.push(encryptedChunk.slice(blocksBytes));\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (toDecrypt) {\r\n\r\n                            debugx(`CHUNK TO DECRYPT: ${toDecrypt.length}`);\r\n\r\n                            let newBuff = decryptStreamThis.innerDecrypt(\r\n                                publication,\r\n                                link,\r\n                                toDecrypt,\r\n                                decryptStreamFinished ? padding : false);\r\n\r\n                            debugx(`CHUNK DECRYPTED: ${newBuff.length}`);\r\n\r\n                            if (decryptStreamFirst) {\r\n                                decryptStreamFirst = false;\r\n                                debugx(\"LcpDecryptStream TRANSFORM decryptStreamBlockOffset: \" +\r\n                                    decryptStreamBlockOffset);\r\n                                newBuff = newBuff.slice(decryptStreamBlockOffset);\r\n                            }\r\n                            decryptStreamBytesSent += newBuff.length;\r\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBytesSent: \" + decryptStreamBytesSent);\r\n                            decryptStream.push(newBuff);\r\n                        }\r\n\r\n                        if (decryptStreamFinished) {\r\n                            debugx(\"LcpDecryptStream FINISHING...\");\r\n                            decryptStreamClosed = true;\r\n                            decryptStream.push(null);\r\n                            decryptStream.end();\r\n                        }\r\n                    } else {\r\n                        // NOOP\r\n                        // no call to this.push(), we skip the entire current chunk buffer\r\n                    }\r\n                }\r\n\r\n                callback();\r\n            },\r\n        });\r\n\r\n        const l = link.Properties.Encrypted.OriginalLength ?\r\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\r\n\r\n        const sal: IStreamAndLength = {\r\n            length: l,\r\n            reset: async () => {\r\n                const resetedStream = await stream.reset();\r\n                return this.transformStream(\r\n                    publication, link,\r\n                    resetedStream,\r\n                    isPartialByteRangeRequest,\r\n                    partialByteBegin, partialByteEnd);\r\n            },\r\n            stream: decryptStream,\r\n        };\r\n        return Promise.resolve(sal);\r\n    }\r\n\r\n    // private async transformStream__(\r\n    //     publication: Publication, link: Link,\r\n    //     stream: IStreamAndLength,\r\n    //     isPartialByteRangeRequest: boolean,\r\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n    //     if (!isPartialByteRangeRequest) {\r\n    //         return this.transformStream_(\r\n    //             publication, link,\r\n    //             stream,\r\n    //             isPartialByteRangeRequest,\r\n    //             partialByteBegin, partialByteEnd);\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() RAW STREAM LENGTH: \" + stream.length);\r\n\r\n    //     let plainTextSize = -1;\r\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n    //         plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n    //     } else {\r\n    //         plainTextSize = await this.getDecryptedSizeStream(publication, link, stream);\r\n    //         debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\r\n    //         stream = await stream.reset();\r\n    //         // length cached to avoid resetting the stream to zero-position\r\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n    //     }\r\n    //     debug(\"LCP transformStream() plainTextSize: \" + plainTextSize);\r\n\r\n    //     if (partialByteBegin < 0) {\r\n    //         partialByteBegin = 0;\r\n    //     }\r\n\r\n    //     if (partialByteEnd < 0) {\r\n    //         partialByteEnd = plainTextSize - 1;\r\n    //         if (link.Properties.Encrypted.OriginalLength) {\r\n    //             partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\r\n    //         }\r\n    //     }\r\n\r\n    //     const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\r\n\r\n    //     debug(\"LCP transformStream() partialByteBegin: \" + partialByteBegin);\r\n    //     debug(\"LCP transformStream() partialByteEnd: \" + partialByteEnd);\r\n    //     debug(\"LCP transformStream() partialByteLength: \" + partialByteLength);\r\n\r\n    //     // block padding scheme\r\n    //     let padding = false; // NO_PADDING\r\n    //     const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\r\n\r\n    //     debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\r\n\r\n    //     if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\r\n    //         padding = true; // W3C_PADDING, also PKCS#7\r\n    //     }\r\n\r\n    //     // byte offset in first block of the cypher text that contains the range begin\r\n    //     const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\r\n\r\n    //     // we read the entire first block, even if partially used\r\n    //     const readPosition = partialByteBegin - blockOffset;\r\n\r\n    //     debug(\"LCP transformStream() blockOffset: \" + blockOffset);\r\n    //     debug(\"LCP transformStream() readPosition: \" + readPosition);\r\n\r\n    //     // number of blocks to read\r\n    //     let blocksCount = 1;\r\n    //     let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\r\n\r\n    //     debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\r\n\r\n    //     if (partialByteLength < bytesInFirstBlock) {\r\n    //         bytesInFirstBlock = 0;\r\n    //     }\r\n    //     if (bytesInFirstBlock > 0) {\r\n    //         blocksCount++;\r\n    //     }\r\n\r\n    //     const diff = partialByteLength - bytesInFirstBlock;\r\n\r\n    //     debug(\"LCP transformStream() diff: \" + diff);\r\n\r\n    //     let inc = diff / AES_BLOCK_SIZE;\r\n    //     debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n    //     inc = Math.floor(inc);\r\n    //     debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n    //     blocksCount += inc;\r\n\r\n    //     const rem = diff % AES_BLOCK_SIZE;\r\n    //     debug(\"LCP transformStream() rem: \" + rem);\r\n\r\n    //     if (rem !== 0) {\r\n    //         blocksCount++;\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() blocksCount: \" + blocksCount);\r\n\r\n    //     // number of bytes to read (block aligned)\r\n    //     const toRead = blocksCount * AES_BLOCK_SIZE;\r\n\r\n    //     debug(\"LCP transformStream() toRead: \" + toRead);\r\n\r\n    //     const rangeStream = new RangeStream(readPosition, readPosition + toRead - 1, stream.length);\r\n    //     stream.stream.pipe(rangeStream);\r\n    //     let buff: Buffer;\r\n    //     try {\r\n    //         buff = await streamToBufferPromise(rangeStream);\r\n    //     } catch (err) {\r\n    //         debug(err);\r\n    //         return Promise.reject(\"OUCH!\");\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() buff.length: \" + buff.length);\r\n\r\n    //     let newBuff = this.innerDecrypt(buff, padding);\r\n\r\n    //     debug(\"LCP transformStream() newBuff.length: \" + newBuff.length);\r\n\r\n    //     if (newBuff.length < partialByteLength) {\r\n    //         debug(\"newBuff.length < partialByteLength\");\r\n    //     }\r\n    //     newBuff = newBuff.slice(blockOffset);\r\n\r\n    //     debug(\"LCP transformStream() newBuff.length (blockOffset): \" + newBuff.length);\r\n\r\n    //     const bufferStream = bufferToStream(newBuff);\r\n\r\n    //     const sal: IStreamAndLength = {\r\n    //         length: plainTextSize, // newBuff.length,\r\n    //         reset: async () => {\r\n    //             const resetedStream = await stream.reset();\r\n    //             return this.transformStream(\r\n    //                 publication, link,\r\n    //                 resetedStream,\r\n    //                 isPartialByteRangeRequest,\r\n    //                 partialByteBegin, partialByteEnd);\r\n    //         },\r\n    //         stream: bufferStream,\r\n    //     };\r\n    //     return Promise.resolve(sal);\r\n    // }\r\n\r\n    // private async transformStream_(\r\n    //     publication: Publication, link: Link,\r\n    //     stream: IStreamAndLength,\r\n    //     isPartialByteRangeRequest: boolean,\r\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n    //     debug(\"LCP transformStream_() RAW STREAM LENGTH: \" + stream.length);\r\n\r\n    //     let l = -1;\r\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n    //         l = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n    //     } else {\r\n    //         l = await this.getDecryptedSizeStream(publication, link, stream);\r\n    //         debug(\"LCP transformStream_() ---- getDecryptedSizeStream(): \" + l);\r\n    //         stream = await stream.reset();\r\n    //         // length cached to avoid resetting the stream to zero-position\r\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = l;\r\n    //     }\r\n\r\n    //     const data = await streamToBufferPromise(stream.stream);\r\n    //     debug(\"LCP transformStream_() RAW BUFFER LENGTH after reset: \" + stream.length);\r\n    //     const buff = await this.transformBuffer(publication, link, data);\r\n    //     debug(\"LCP transformStream_() DECRYPTED BUFFER LENGTH: \" + buff.length);\r\n\r\n    //     if (partialByteBegin < 0) {\r\n    //         partialByteBegin = 0;\r\n    //     }\r\n    //     if (partialByteEnd < 0) {\r\n    //         partialByteEnd = buff.length - 1;\r\n    //     }\r\n\r\n    //     if (isPartialByteRangeRequest) {\r\n    //         debug(\"LCP transformStream_() PARTIAL: \" + partialByteBegin + \" - \" + partialByteEnd);\r\n\r\n    //         const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, buff.length);\r\n    //         const bufferStream = bufferToStream(buff);\r\n    //         bufferStream.pipe(rangeStream);\r\n\r\n    //         const sal: IStreamAndLength = {\r\n    //             length: buff.length, // (partialByteEnd + 1) - partialByteBegin,\r\n    //             reset: async () => {\r\n    //                 const resetedStream = await stream.reset();\r\n    //                 return this.transformStream(\r\n    //                     publication, link,\r\n    //                     resetedStream,\r\n    //                     isPartialByteRangeRequest,\r\n    //                     partialByteBegin, partialByteEnd);\r\n    //             },\r\n    //             stream: rangeStream,\r\n    //         };\r\n    //         return Promise.resolve(sal);\r\n    //     } else {\r\n    //         debug(\"LCP transformStream_() WHOLE: \" + buff.length);\r\n\r\n    //         const sal: IStreamAndLength = {\r\n    //             length: buff.length,\r\n    //             reset: async () => {\r\n    //                 return Promise.resolve(sal);\r\n    //             },\r\n    //             stream: bufferToStream(buff),\r\n    //         };\r\n    //         return Promise.resolve(sal);\r\n    //     }\r\n    // }\r\n\r\n    // private async getDecryptedSizeBuffer(_publication: Publication, _link: Link, data: Buffer): Promise<number> {\r\n\r\n    //     const totalByteLength = data.length;\r\n\r\n    //     const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\r\n    //     if (totalByteLength < TWO_AES_BLOCK_SIZE) {\r\n    //         return 0;\r\n    //     }\r\n    //     const readPos = totalByteLength - TWO_AES_BLOCK_SIZE;\r\n\r\n    //     const buff = data.slice(readPos, totalByteLength);\r\n\r\n    //     return this.getDecryptedSizeBuffer_(totalByteLength, buff);\r\n    // }\r\n\r\n    protected innerDecrypt(\r\n        publication: Publication, _link: Link,\r\n        data: Buffer, padding: boolean): Buffer {\r\n        // debug(\"LCP innerDecrypt() data.length: \" + data.length);\r\n        // debug(\"LCP innerDecrypt() padding: \" + padding);\r\n\r\n        const contentKey = publication.LCP.ContentKey;\r\n\r\n        const buffIV = data.slice(0, AES_BLOCK_SIZE);\r\n        // debug(\"LCP innerDecrypt() buffIV.length: \" + buffIV.length);\r\n\r\n        // TODO: keep buffer to avoid costly string conversion?\r\n        const iv = buffIV.toString(\"binary\");\r\n\r\n        const buffToDecrypt = data.slice(AES_BLOCK_SIZE);\r\n        // debug(\"LCP innerDecrypt() buffToDecrypt: \" + buffToDecrypt.length);\r\n\r\n        // TODO: keep buffer to avoid costly string conversion?\r\n        const strToDecrypt = buffToDecrypt.toString(\"binary\");\r\n        const toDecrypt =\r\n            forge.util.createBuffer(strToDecrypt, \"binary\");\r\n\r\n        const aesCbcDecipher = (forge as any).cipher.createDecipher(\"AES-CBC\", contentKey);\r\n        aesCbcDecipher.start({ iv, additionalData_: \"binary-encoded string\" });\r\n        aesCbcDecipher.update(toDecrypt);\r\n\r\n        function unpadFunc() { return false; }\r\n        // const res =\r\n        aesCbcDecipher.finish(padding ? undefined : unpadFunc);\r\n        // debug(res);\r\n\r\n        const decryptedZipData = aesCbcDecipher.output.bytes();\r\n\r\n        // debug(forge.util.bytesToHex(decryptedZipData));\r\n        // debug(decryptedZipData.toHex());\r\n\r\n        const buff = new Buffer(decryptedZipData, \"binary\");\r\n\r\n        // debug(\"LCP innerDecrypt() buff.length: \" + buff.length);\r\n\r\n        return buff;\r\n    }\r\n\r\n    // protected async getDecryptedSizeBuffer_(totalByteLength: number, buff: Buffer): Promise<ICryptoInfo> {\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() totalByteLength: \" + totalByteLength);\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() buff.length: \" + buff.length);\r\n\r\n    //     const padding = true;\r\n    //     const newBuff = this.innerDecrypt(buff, padding);\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() newBuff.length (innerDecrypt): \" + newBuff.length);\r\n\r\n    //     // newBuff.length === 0\r\n    //     // when last second block is all padding,\r\n    //     // otherwise newBuff.length === overflow encrypted bytes,\r\n    //     // number between [1, AES_BLOCK_SIZE[\r\n    //     const nPaddingBytes = padding ? (AES_BLOCK_SIZE - newBuff.length) : newBuff[15];\r\n    //     // debugx(\"LCP getDecryptedSizeBuffer_() nPaddingBytes: \" + nPaddingBytes);\r\n\r\n    //     const size = totalByteLength - AES_BLOCK_SIZE - nPaddingBytes;\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() size: \" + size);\r\n\r\n    //     const res: ICryptoInfo = {\r\n    //         length: size,\r\n    //         padding: nPaddingBytes,\r\n    //     };\r\n\r\n    //     return Promise.resolve(res);\r\n    // }\r\n\r\n    // private async transformBuffer(_publication: Publication, link: Link, data: Buffer): Promise<Buffer> {\r\n\r\n    //     const l = await this.getDecryptedSizeBuffer(_publication, link, data);\r\n    //     debug(\"LCP transformBuffer() ==== decrypted buffer length CHECK: \" + l);\r\n\r\n    //     let transformedData = this.innerDecrypt(data, true);\r\n\r\n    //     debug(\"LCP transformBuffer() decrypted buffer length before INFLATE: \" + transformedData.length);\r\n\r\n    //     if (link.Properties.Encrypted.Compression === \"deflate\") {\r\n    //         transformedData = zlib.inflateRawSync(transformedData);\r\n    //     }\r\n\r\n    //     debug(\"LCP transformBuffer() decrypted buffer length after INFLATE: \" + transformedData.length);\r\n\r\n    //     if (link.Properties.Encrypted.OriginalLength\r\n    //         && link.Properties.Encrypted.OriginalLength !== transformedData.length) {\r\n    //         debug(`LENGTH NOT MATCH ${link.Properties.Encrypted.OriginalLength} !== ${transformedData.length}`);\r\n    //     }\r\n\r\n    //     return Promise.resolve(transformedData);\r\n    // }\r\n}\r\n"]}