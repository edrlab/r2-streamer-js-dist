{"version":3,"file":"lsd.js","sourceRoot":"","sources":["../../../../src/electron/lsd.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\n\nimport { Publication } from \"@models/publication\";\nimport { LCP } from \"@parser/epub/lcp\";\nimport { streamToBufferPromise } from \"@utils/stream/BufferUtils\";\nimport { injectBufferInZip } from \"@utils/zip/zipInjector\";\nimport * as debug_ from \"debug\";\nimport * as moment from \"moment\";\nimport * as request from \"request\";\nimport * as requestPromise from \"request-promise-native\";\nimport { JSON as TAJSON } from \"ta-json\";\n\nconst debug = debug_(\"r2:lsd\");\n\nexport interface IDeviceIDManager {\n    getDeviceNAME(): string;\n\n    getDeviceID(): string;\n\n    checkDeviceID(key: string): string;\n\n    recordDeviceID(key: string): void;\n}\n\nexport async function launchStatusDocumentProcessing(\n    publication: Publication,\n    publicationPath: string,\n    _deviceIDManager: IDeviceIDManager,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    if (!publication.LCP || !publication.LCP.Links) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n    const linkStatus = publication.LCP.Links.find((link) => {\n        return link.Rel === \"status\";\n    });\n    if (!linkStatus) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n\n    debug(linkStatus);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            failure(\"HTTP CODE \" + response.statusCode);\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const responseStr = responseData.toString(\"utf8\");\n        debug(responseStr);\n        const responseJson = global.JSON.parse(responseStr);\n        debug(responseJson);\n\n        // debug(responseJson.id);\n        // debug(responseJson.status); // revoked, returned, cancelled, expired\n        // debug(responseJson.message);\n        // if (responseJson.updated) {\n        //     debug(responseJson.updated.license);\n        //     debug(responseJson.updated.status);\n        // }\n        // if (responseJson.links) {\n        //     responseJson.links.forEach((link: any) => {\n        //         debug(link.rel); // license, register, return, renew\n        //         debug(link.href);\n        //         debug(link.type);\n        //         debug(link.templated);\n        //         debug(link.title);\n        //         debug(link.profile);\n        //     });\n        // }\n        // if (responseJson.potential_rights) {\n        //     debug(responseJson.potential_rights.end);\n        // }\n        // if (responseJson.events) {\n        //     responseJson.events.forEach((event: any) => {\n        //         debug(event.type);\n        //         debug(event.name);\n        //         debug(event.timestamp); // ISO 8601 time and date\n        //         debug(event.id);\n        //     });\n        // }\n\n        if (responseJson.updated && responseJson.updated.license &&\n            (publication.LCP.Updated || publication.LCP.Issued)) {\n            const updatedLicenseLSD = moment(responseJson.updated.license);\n            const updatedLicense = moment(publication.LCP.Updated || publication.LCP.Issued);\n            const forceUpdate = false;\n            if (forceUpdate || updatedLicense.isBefore(updatedLicenseLSD)) {\n                debug(\"LSD license updating...\");\n                if (responseJson.links) {\n                    const licenseLink = responseJson.links.find((link: any) => {\n                        return link.rel === \"license\";\n                    });\n                    if (!licenseLink) {\n                        debug(\"LSD license link is missing.\");\n                        onStatusDocumentProcessingComplete();\n                        return;\n                    }\n                    await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                        licenseLink.href, onStatusDocumentProcessingComplete);\n                    return;\n                }\n            }\n        }\n        onStatusDocumentProcessingComplete();\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: linkStatus.Href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: linkStatus.Href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n\nasync function fetchAndInjectUpdatedLicense(\n    publication: Publication,\n    publicationPath: string,\n    href: string,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    debug(\"OLD LCP LICENSE, FETCHING LSD UPDATE ... \" + href);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            if (href.indexOf(\"/licenses/\") > 0) {\n                const newHref = href.replace(\"/licenses/\", \"/api/v1/purchases/license/\");\n                debug(\"TRYING AGAIN: \" + newHref);\n                await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                        newHref, onStatusDocumentProcessingComplete);\n            } else {\n                failure(\"HTTP CODE \" + response.statusCode);\n            }\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const lcplStr = responseData.toString(\"utf8\");\n        debug(lcplStr);\n\n        const zipEntryPath = \"META-INF/license.lcpl\";\n\n        let lcpl: LCP | undefined;\n        try {\n            const lcplJson = global.JSON.parse(lcplStr);\n            debug(lcplJson);\n            lcpl = TAJSON.deserialize<LCP>(lcplJson, LCP);\n        } catch (erorz) {\n            debug(erorz);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!lcpl) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        lcpl.ZipPath = zipEntryPath;\n        lcpl.JsonSource = lcplStr;\n        lcpl.init();\n        publication.LCP = lcpl;\n        // publication.AddLink(\"application/vnd.readium.lcp.license-1.0+json\", [\"license\"],\n        //     lcpl.ZipPath, false);\n\n        const newPublicationPath = publicationPath + \".new\";\n        injectBufferInZip(publicationPath, newPublicationPath, responseData, zipEntryPath,\n            (err) => {\n                debug(err);\n                onStatusDocumentProcessingComplete();\n            },\n            () => {\n                debug(\"EPUB license.lcpl injected.\");\n\n                setTimeout(() => {\n                    fs.unlinkSync(publicationPath);\n                    setTimeout(() => {\n                        fs.renameSync(newPublicationPath, publicationPath);\n                        onStatusDocumentProcessingComplete();\n                    }, 500);\n                }, 500);\n            });\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n"]}