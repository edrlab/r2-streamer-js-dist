{"version":3,"file":"self-signed.js","sourceRoot":"","sources":["../../../../src/utils/self-signed.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AACjC,yCAAyC;AACzC,6BAA6B;AAgB7B;;QACI,MAAM,CAAC,IAAI,OAAO,CAAkB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACpD,MAAM,IAAI,GAAG;gBACT,SAAS,EAAE,QAAQ;gBAGnB,IAAI,EAAE,EAAE;gBACR,UAAU,EAAE,CAAC;wBACT,QAAQ,EAAE,CAAC;gCACP,IAAI,EAAE,CAAC;gCACP,KAAK,EAAE,WAAW;6BACrB,CAAC;wBACF,IAAI,EAAE,gBAAgB;qBACzB,CAAC;aACL,CAAC;YACF,MAAM,IAAI,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;YACvB,MAAM,UAAU,GAAG,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,qBAAqB,GAAG,IAAI,EAAE,CAAC,CAAC;YAEjF,UAAU,CAAC,QAAQ,CAAC,UAAU,EAAE,IAAI,EAAE,CAAC,GAAQ,EAAE,IAAS,EAAE,EAAE;gBAC1D,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACN,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,MAAM,CAAC;gBACX,CAAC;gBAED,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;gBAC7C,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC;gBAC3B,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;gBAChD,IAAwB,CAAC,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBAE5D,MAAM,cAAc,GAAG,EAAE,CAAC;gBAC1B,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;gBACpB,IAAwB,CAAC,UAAU,GAAG,EAAE,CAAC;gBAC1C,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC;gBAC9B,MAAM,EAAE,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;gBAC1C,IAAwB,CAAC,YAAY,GAAG,EAAE,CAAC;gBAE5C,OAAO,CAAC,IAAuB,CAAC,CAAC;YACrC,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;CAAA;AAvCD,wDAuCC","sourcesContent":["import * as crypto from \"crypto\";\nimport * as selfsigned from \"selfsigned\";\nimport * as uuid from \"uuid\";\n\nexport interface CertificateData {\n    trustKey: Buffer;\n    trustCheck: string;\n    trustCheckIV: Buffer;\n\n    // clientprivate?: string;\n    // clientpublic?: string;\n    // clientcert?: string;\n\n    private?: string; // https.ServerOptions.key\n    public?: string;\n    cert?: string; // https.ServerOptions.cert\n}\n\nexport async function generateSelfSignedData(): Promise<CertificateData> {\n    return new Promise<CertificateData>((resolve, reject) => {\n        const opts = {\n            algorithm: \"sha256\",\n            // clientCertificate: true,\n            // clientCertificateCN: \"R2 insecure client\",\n            days: 30,\n            extensions: [{\n                altNames: [{\n                    type: 2, // DNSName\n                    value: \"localhost\",\n                }],\n                name: \"subjectAltName\",\n            }],\n        };\n        const rand = uuid.v4();\n        const attributes = [{ name: \"commonName\", value: \"R2 insecure server \" + rand }];\n\n        selfsigned.generate(attributes, opts, (err: any, keys: any) => {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            const checkSum = crypto.createHash(\"sha256\");\n            checkSum.update(uuid.v4());\n            const key = checkSum.digest(\"hex\").toUpperCase();\n            (keys as CertificateData).trustKey = new Buffer(key, \"hex\");\n\n            const AES_BLOCK_SIZE = 16;\n            const ck = uuid.v4();\n            (keys as CertificateData).trustCheck = ck;\n            const ivBuff = new Buffer(ck);\n            const iv = ivBuff.slice(0, AES_BLOCK_SIZE);\n            (keys as CertificateData).trustCheckIV = iv;\n\n            resolve(keys as CertificateData);\n        });\n    });\n}\n"]}