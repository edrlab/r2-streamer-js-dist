{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../../../../src/_utils/zip/zip.ts"],"names":[],"mappings":";;;AAAA,qDAAoD;AAkBpD;IAAA;IAsCA,CAAC;IA9BgB,qCAAuB,GAApC,UAAqC,SAAiB,EAAE,KAAa,EAAE,GAAW;;;;;;;;wBAIxD,WAAM,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAA;;wBAA1D,eAAe,GAAG,SAAwC,CAAC;;;;wBAE3D,OAAO,CAAC,GAAG,CAAC,KAAG,CAAC,CAAC;wBACjB,WAAO,OAAO,CAAC,MAAM,CAAC,KAAG,CAAC,EAAC;;wBAG/B,eAAe,GAAG,eAAmC,CAAC;wBAEhD,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;wBAC1B,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;wBAIjD,MAAM,GAAG,IAAI,yBAAW,CAAC,CAAC,EAAE,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,CAAC;wBAE7D,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAE9B,GAAG,GAAqB;4BAC1B,MAAM,EAAE,eAAe,CAAC,MAAM;4BAC9B,KAAK,EAAE;;oCACH,WAAO,IAAI,CAAC,uBAAuB,CAAC,SAAS,EAAE,KAAK,EAAE,GAAG,CAAC,EAAC;;iCAC9D;4BACD,MAAM,QAAA;yBACT,CAAC;wBACF,WAAO,GAAG,EAAC;;;;KACd;IACL,UAAC;AAAD,CAAC,AAtCD,IAsCC;AAtCqB,kBAAG","sourcesContent":["import { RangeStream } from \"../stream/RangeStream\";\r\n\r\nexport interface IStreamAndLength {\r\n    stream: NodeJS.ReadableStream;\r\n    length: number;\r\n    reset: () => Promise<IStreamAndLength>;\r\n}\r\n\r\nexport interface IZip {\r\n    hasEntries: () => boolean;\r\n    entriesCount: () => number;\r\n    hasEntry: (entryPath: string) => boolean;\r\n    forEachEntry: (callback: (entryName: string) => void) => void;\r\n    entryStreamPromise: (entryPath: string) => Promise<IStreamAndLength>;\r\n    entryStreamRangePromise: (entryPath: string, begin: number, end: number) => Promise<IStreamAndLength>;\r\n    freeDestroy: () => void;\r\n}\r\n\r\nexport abstract class Zip implements IZip {\r\n    public abstract hasEntries(): boolean;\r\n    public abstract entriesCount(): number;\r\n    public abstract hasEntry(entryPath: string): boolean;\r\n    public abstract forEachEntry(callback: (entryName: string) => void): void;\r\n    public abstract entryStreamPromise(entryPath: string): Promise<IStreamAndLength>;\r\n    public abstract freeDestroy(): void;\r\n\r\n    public async entryStreamRangePromise(entryPath: string, begin: number, end: number): Promise<IStreamAndLength> {\r\n\r\n        let streamAndLength: IStreamAndLength;\r\n        try {\r\n            streamAndLength = await this.entryStreamPromise(entryPath);\r\n        } catch (err) {\r\n            console.log(err);\r\n            return Promise.reject(err);\r\n        }\r\n        // necessary for TypeScript compiler :(\r\n        streamAndLength = streamAndLength as IStreamAndLength;\r\n\r\n        const b = begin < 0 ? 0 : begin;\r\n        const e = end < 0 ? (streamAndLength.length - 1) : end;\r\n        // const length = e - b + 1;\r\n        // debug(`entryStreamRangePromise: ${b}-${e}/${streamAndLength.length}`);\r\n\r\n        const stream = new RangeStream(b, e, streamAndLength.length);\r\n\r\n        streamAndLength.stream.pipe(stream);\r\n\r\n        const sal: IStreamAndLength = {\r\n            length: streamAndLength.length,\r\n            reset: async () => {\r\n                return this.entryStreamRangePromise(entryPath, begin, end);\r\n            },\r\n            stream,\r\n        };\r\n        return sal;\r\n    }\r\n}\r\n"]}