{"version":3,"file":"BufferUtils.js","sourceRoot":"","sources":["../../../../../src/_utils/stream/BufferUtils.ts"],"names":[],"mappings":";;;AAAA,2EAA0E;AAG1E,wBAA+B,MAAc;IAEzC,MAAM,CAAC,IAAI,2CAAoB,CAAC,MAAM,CAAC,CAAC;AA+D5C,CAAC;AAjED,wCAiEC;AAED,wCAAqD,UAAiC;;;YAElF,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;oBAE/B,UAAU,CAAC,EAAE,CAAC,UAAU,EAAE;wBACtB,IAAI,KAAa,CAAC;wBAClB,GAAG,CAAC;4BACA,KAAK,GAAG,UAAU,CAAC,IAAI,EAAY,CAAC;4BACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gCACR,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;4BACxB,CAAC;wBACL,CAAC,QACM,KAAK,EAAE;oBAClB,CAAC,CAAC,CAAC;oBAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE;wBACjB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AAvBD,wEAuBC;AAED,+BAA4C,UAAiC;;;YAEzE,WAAO,IAAI,OAAO,CAAS,UAAC,OAAO,EAAE,MAAM;oBAEvC,IAAM,OAAO,GAAa,EAAE,CAAC;oBAE7B,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;oBAE/B,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE,UAAC,IAAY;wBAC/B,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACvB,CAAC,CAAC,CAAC;oBAEH,UAAU,CAAC,EAAE,CAAC,KAAK,EAAE;wBACjB,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC,CAAC;gBACP,CAAC,CAAC,EAAC;;;CACN;AAhBD,sDAgBC","sourcesContent":["import { BufferReadableStream } from \"@utils/stream/BufferReadableStream\";\r\n// import { PassThrough } from \"stream\";\r\n\r\nexport function bufferToStream(buffer: Buffer): NodeJS.ReadableStream {\r\n\r\n    return new BufferReadableStream(buffer);\r\n\r\n    // const stream = new PassThrough();\r\n\r\n    // setTimeout(() => {\r\n\r\n    //     // stream.write(buffer);\r\n    //     // stream.end();\r\n\r\n    //     // const maxBuffLength = 2048; // 2kB\r\n    //     let maxBuffLength = 100 * 1024; // 100kB\r\n\r\n    //     let buff = buffer;\r\n    //     let remaining = buff.length;\r\n    //     let done = 0;\r\n\r\n    //     console.log(\"bufferToStream()  BEFORE: \" + remaining);\r\n\r\n    //     while (remaining > 0) {\r\n\r\n    //         if (done > 0) {\r\n    //             buff = buffer.slice(done);\r\n    //             // remaining === buff.length\r\n    //         }\r\n\r\n    //         if (buff.length > maxBuffLength) {\r\n    //             buff = buff.slice(0, maxBuffLength);\r\n    //         }\r\n\r\n    //         const res = stream.write(buff);\r\n    //         if (!res) {\r\n    //             console.log(\"bufferToStream()  highWaterMark\");\r\n\r\n    //             // Buffer highWaterMark CHECK\r\n    //             if ((stream as any)._writableState) {\r\n    //                 const internalStreamWriteBuffer = (stream as any)._writableState.getBuffer();\r\n    //                 if (internalStreamWriteBuffer) {\r\n    //                     console.log(\"bufferToStream() _writableState.getBuffer().length: \"\r\n    // + internalStreamWriteBuffer.length);\r\n    //                 }\r\n    //             }\r\n\r\n    //             // Buffer highWaterMark CHECK\r\n    //             if ((stream as any)._readableState) {\r\n    //                 const internalStreamReadBuffer = (stream as any)._readableState.buffer;\r\n    //                 if (internalStreamReadBuffer) {\r\n    //                     console.log(\"bufferToStream() _readableState.buffer.length: \"\r\n    // + internalStreamReadBuffer.length);\r\n    //                 }\r\n    //             }\r\n\r\n    //         }\r\n\r\n    //         done += buff.length;\r\n    //         remaining -= buff.length;\r\n    //     }\r\n\r\n    //     console.log(\"bufferToStream()  AFTER: \" + done);\r\n\r\n    //     stream.end();\r\n    // }, 20);\r\n\r\n    // return stream;\r\n}\r\n\r\nexport async function streamToBufferPromise_READABLE(readStream: NodeJS.ReadableStream): Promise<Buffer> {\r\n\r\n    return new Promise<Buffer>((resolve, reject) => {\r\n\r\n        const buffers: Buffer[] = [];\r\n\r\n        readStream.on(\"error\", reject);\r\n\r\n        readStream.on(\"readable\", () => {\r\n            let chunk: Buffer;\r\n            do {\r\n                chunk = readStream.read() as Buffer;\r\n                if (chunk) {\r\n                    buffers.push(chunk);\r\n                }\r\n            }\r\n            while (chunk);\r\n        });\r\n\r\n        readStream.on(\"end\", () => {\r\n            resolve(Buffer.concat(buffers));\r\n        });\r\n    });\r\n}\r\n\r\nexport async function streamToBufferPromise(readStream: NodeJS.ReadableStream): Promise<Buffer> {\r\n\r\n    return new Promise<Buffer>((resolve, reject) => {\r\n\r\n        const buffers: Buffer[] = [];\r\n\r\n        readStream.on(\"error\", reject);\r\n\r\n        readStream.on(\"data\", (data: Buffer) => {\r\n            buffers.push(data);\r\n        });\r\n\r\n        readStream.on(\"end\", () => {\r\n            resolve(Buffer.concat(buffers));\r\n        });\r\n    });\r\n}\r\n"]}