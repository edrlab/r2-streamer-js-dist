{"version":3,"file":"transformer-lcp.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from \"crypto\";\r\nimport * as zlib from \"zlib\";\r\n\r\nimport { Publication } from \"@models/publication\";\r\nimport { Link } from \"@models/publication-link\";\r\nimport { RangeStream } from \"@utils/stream/RangeStream\";\r\nimport { IStreamAndLength } from \"@utils/zip/zip\";\r\nimport * as debug_ from \"debug\";\r\n\r\nimport { ITransformer } from \"./transformer\";\r\n\r\n// import * as forge from \"node-forge\";\r\nimport { bufferToStream, streamToBufferPromise } from \"@utils/stream/BufferUtils\";\r\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\r\n// import { Transform } from \"stream\";\r\n\r\nconst debug = debug_(\"r2:transformer:lcp\");\r\n// const debugx = debug_(\"r2:transformer:stream:lcp\");\r\n\r\nconst AES_BLOCK_SIZE = 16;\r\n\r\n// let streamCounter = 0;\r\n\r\nconst readStream = async (s: NodeJS.ReadableStream, n: number): Promise<Buffer> => {\r\n    return new Promise<Buffer>((resolve, reject) => {\r\n        // s.pause();\r\n        const onReadable = () => {\r\n            // debug(\"readStream READABLE\");\r\n            const b = s.read(n);\r\n            s.removeListener(\"readable\", onReadable);\r\n            s.removeListener(\"error\", reject);\r\n            // s.resume();\r\n            resolve(b as Buffer);\r\n        };\r\n        s.on(\"readable\", onReadable);\r\n        s.on(\"error\", reject);\r\n        // s.on(\"end\", () => {\r\n        //     debug(\"readStream END\");\r\n        // });\r\n        // s.on(\"drain\", () => {\r\n        //     debug(\"readStream DRAIN\");\r\n        // });\r\n        // s.on(\"finish\", () => {\r\n        //     debug(\"readStream FINISH\");\r\n        // });\r\n    });\r\n};\r\n\r\nexport interface ICryptoInfo {\r\n    length: number;\r\n    padding: number;\r\n}\r\n\r\nexport class TransformerLCP implements ITransformer {\r\n\r\n    public supports(publication: Publication, link: Link): boolean {\r\n\r\n        if (!publication.LCP) {\r\n            return false;\r\n        }\r\n\r\n        if (!publication.LCP.isReady()) {\r\n            debug(\"LCP not ready!\");\r\n            return false;\r\n        }\r\n\r\n        const check = link.Properties.Encrypted.Scheme === \"http://readium.org/2014/01/lcp\"\r\n            && (link.Properties.Encrypted.Profile === \"http://readium.org/lcp/basic-profile\" ||\r\n                link.Properties.Encrypted.Profile === \"http://readium.org/lcp/profile-1.0\")\r\n            && link.Properties.Encrypted.Algorithm === \"http://www.w3.org/2001/04/xmlenc#aes256-cbc\"\r\n            ;\r\n        if (!check) {\r\n            debug(\"Incorrect resource LCP fields.\");\r\n            debug(link.Properties.Encrypted.Scheme);\r\n            debug(link.Properties.Encrypted.Profile);\r\n            debug(link.Properties.Encrypted.Algorithm);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public async transformStream(\r\n        publication: Publication,\r\n        link: Link,\r\n        stream: IStreamAndLength,\r\n        isPartialByteRangeRequest: boolean,\r\n        partialByteBegin: number,\r\n        partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n        let plainTextSize = -1;\r\n\r\n        let nativelyDecryptedStream: NodeJS.ReadableStream | undefined;\r\n        if (publication.LCP.isNativeNodePlugin()) {\r\n\r\n            debug(\"DECRYPT: \" + link.Href);\r\n\r\n            let fullEncryptedBuffer: Buffer;\r\n            try {\r\n                fullEncryptedBuffer = await streamToBufferPromise(stream.stream);\r\n            } catch (err) {\r\n                debug(err);\r\n                return Promise.reject(\"OUCH!\");\r\n            }\r\n\r\n            // debug(fullEncryptedBuffer.length);\r\n\r\n            // debug(fullEncryptedBuffer.slice(0, 32));\r\n\r\n            // debug(fullEncryptedBuffer.slice(fullEncryptedBuffer.length - 32));\r\n\r\n            let nativelyDecryptedBuffer: Buffer;\r\n            try {\r\n                nativelyDecryptedBuffer = await publication.LCP.decrypt(fullEncryptedBuffer);\r\n            } catch (err) {\r\n                debug(err);\r\n                return Promise.reject(\"OUCH!\");\r\n            }\r\n\r\n            // debug(nativelyDecryptedBuffer.length);\r\n\r\n            plainTextSize = nativelyDecryptedBuffer.length;\r\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n\r\n            if (link.Properties.Encrypted.OriginalLength &&\r\n                link.Properties.Encrypted.Compression === \"none\" &&\r\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\r\n\r\n                debug(`############### ` +\r\n                    `LCP transformStream() LENGTH NOT MATCH ` +\r\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize: ` +\r\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\r\n            }\r\n\r\n            nativelyDecryptedStream = bufferToStream(nativelyDecryptedBuffer);\r\n        } else {\r\n            let cryptoInfo: ICryptoInfo | undefined;\r\n            let cypherBlockPadding = -1;\r\n            if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n                plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n                cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\r\n            } else {\r\n                // const timeBegin = process.hrtime();\r\n                try {\r\n                    cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\r\n                } catch (err) {\r\n                    debug(err);\r\n                    return Promise.reject(err);\r\n                }\r\n                plainTextSize = cryptoInfo.length;\r\n                cypherBlockPadding = cryptoInfo.padding;\r\n\r\n                // length cached to avoid resetting the stream to zero-position\r\n                link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n                link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\r\n\r\n                try {\r\n                    stream = await stream.reset();\r\n                } catch (err) {\r\n                    debug(err);\r\n                    return Promise.reject(err);\r\n                }\r\n\r\n                // const timeElapsed = process.hrtime(timeBegin);\r\n                // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\r\n                //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\r\n\r\n                // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\r\n\r\n                if (link.Properties.Encrypted.OriginalLength &&\r\n                    link.Properties.Encrypted.Compression === \"none\" &&\r\n                    link.Properties.Encrypted.OriginalLength !== plainTextSize) {\r\n\r\n                    debug(`############### ` +\r\n                        `LCP transformStream() LENGTH NOT MATCH ` +\r\n                        `link.Properties.Encrypted.OriginalLength !== plainTextSize: ` +\r\n                        `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (partialByteBegin < 0) {\r\n            partialByteBegin = 0;\r\n        }\r\n\r\n        if (partialByteEnd < 0) {\r\n            partialByteEnd = plainTextSize - 1;\r\n            if (link.Properties.Encrypted.OriginalLength) {\r\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\r\n            }\r\n        }\r\n\r\n        let destStream: NodeJS.ReadableStream;\r\n        if (nativelyDecryptedStream) {\r\n            destStream = nativelyDecryptedStream;\r\n        } else {\r\n            // const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\r\n\r\n            let rawDecryptStream: NodeJS.ReadableStream | undefined;\r\n\r\n            let ivBuffer: Buffer | undefined;\r\n            if (link.Properties.Encrypted.CypherBlockIV) {\r\n                ivBuffer = Buffer.from(link.Properties.Encrypted.CypherBlockIV, \"binary\");\r\n\r\n                const cypherRangeStream = new RangeStream(AES_BLOCK_SIZE, stream.length - 1, stream.length);\r\n                stream.stream.pipe(cypherRangeStream);\r\n                rawDecryptStream = cypherRangeStream;\r\n            } else {\r\n                // const ivRangeStream = new RangeStream(0, AES_BLOCK_SIZE - 1, stream.length);\r\n                // stream.stream.pipe(ivRangeStream);\r\n                // try {\r\n                //     ivBuffer = await streamToBufferPromise(ivRangeStream);\r\n                // } catch (err) {\r\n                //     debug(err);\r\n                //     return Promise.reject(\"OUCH!\");\r\n                // }\r\n                // try {\r\n                //     stream = await stream.reset();\r\n                // } catch (err) {\r\n                //     debug(err);\r\n                //     return Promise.reject(err);\r\n                // }\r\n\r\n                // debug(\"D1\");\r\n                // debug(ivBuffer.length);\r\n                // debug(ivBuffer.toString(\"hex\"));\r\n\r\n                // ivBuffer = stream.stream.read(AES_BLOCK_SIZE) as Buffer;\r\n\r\n                try {\r\n                    ivBuffer = await readStream(stream.stream, AES_BLOCK_SIZE);\r\n                } catch (err) {\r\n                    debug(err);\r\n                    return Promise.reject(err);\r\n                }\r\n\r\n                // debug(\"D2\");\r\n                // debug(ivBuffer.length);\r\n                // debug(ivBuffer.toString(\"hex\"));\r\n                // b06ca4cec8831eb158f1a317503f5101\r\n                // === asharedculture_soundtrack.mp3\r\n                //\r\n                // 07e6870e5d708f39e98316b5c0a574c5\r\n                // === shared-culture.mp4\r\n\r\n                link.Properties.Encrypted.CypherBlockIV = ivBuffer.toString(\"binary\");\r\n\r\n                stream.stream.resume();\r\n                rawDecryptStream = stream.stream;\r\n            }\r\n            // debug(\"IV: \" + forge.util.bytesToHex(ivBuffer));\r\n\r\n            // debug(forge.util.bytesToHex(contentKey as string));\r\n\r\n            // https://github.com/nodejs/node/blob/master/lib/crypto.js#L259\r\n            const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\r\n                publication.LCP.ContentKey, // new Buffer(contentKey as string, \"binary\"),\r\n                ivBuffer);\r\n            decryptStream.setAutoPadding(false);\r\n            rawDecryptStream.pipe(decryptStream);\r\n\r\n            destStream = decryptStream;\r\n\r\n            if (link.Properties.Encrypted.CypherBlockPadding) {\r\n                // debugx(\"cryptoInfo.padding: \" + cypherBlockPadding);\r\n                const cypherUnpaddedStream = new RangeStream(0, plainTextSize - 1, plainTextSize);\r\n                destStream.pipe(cypherUnpaddedStream);\r\n                destStream = cypherUnpaddedStream;\r\n            }\r\n\r\n            // const counterStream2 = new CounterPassThroughStream(++streamCounter);\r\n            // destStream.pipe(counterStream2)\r\n            //     .on(\"progress\", function f() {\r\n            //         // debug(\"Crypto PROGRESS: \" +\r\n            //         //     (this as CounterPassThroughStream).id +\r\n            //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\r\n            //     })\r\n            //     .on(\"end\", function f() {\r\n            //         debug(\"Crypto END: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"close\", function f() {\r\n            //         debug(\"Crypto CLOSE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .once(\"finish\", function f() {\r\n            //         debug(\"Crypto FINISH: \" +\r\n            //             (this as CounterPassThroughStream).id +\r\n            //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\r\n\r\n            //         if (plainTextSize !==\r\n            //             (this as CounterPassThroughStream).bytesReceived) {\r\n\r\n            //             debug(`############### ` +\r\n            //                 `LCP Crypto LENGTH NOT MATCH ` +\r\n            //                 `plainTextSize !== bytesReceived:` +\r\n            //                 `${plainTextSize} !== ` +\r\n            //                 `${(this as CounterPassThroughStream).bytesReceived}`);\r\n            //         }\r\n            //     })\r\n            //     .on(\"error\", function f() {\r\n            //         debug(\"CounterPassThroughStream ERROR: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"pipe\", function f() {\r\n            //         debug(\"CounterPassThroughStream PIPE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"unpipe\", function f() {\r\n            //         debug(\"CounterPassThroughStream UNPIPE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"drain\", function f() {\r\n            //         // debug(\"CounterPassThroughStream DRAIN: \" +\r\n            //         //     (this as CounterPassThroughStream).id);\r\n            //     });\r\n            // destStream = counterStream2;\r\n        }\r\n\r\n        if (link.Properties.Encrypted.Compression === \"deflate\") {\r\n\r\n            // https://github.com/nodejs/node/blob/master/lib/zlib.js\r\n            const inflateStream = zlib.createInflateRaw();\r\n            destStream.pipe(inflateStream);\r\n            destStream = inflateStream;\r\n\r\n            // const counterStream = new CounterPassThroughStream(++streamCounter);\r\n            // inflateStream.pipe(counterStream)\r\n            //     .on(\"progress\", function f() {\r\n            //         // debug(\"CounterPassThroughStream PROGRESS: \" +\r\n            //         //     (this as CounterPassThroughStream).id +\r\n            //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\r\n            //     })\r\n            //     .on(\"end\", function f() {\r\n            //         debug(\"CounterPassThroughStream END: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"close\", function f() {\r\n            //         debug(\"CounterPassThroughStream CLOSE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .once(\"finish\", function f() {\r\n            //         debug(\"CounterPassThroughStream FINISH: \" +\r\n            //             (this as CounterPassThroughStream).id +\r\n            //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\r\n\r\n            //         if (link.Properties.Encrypted.OriginalLength &&\r\n            //             link.Properties.Encrypted.OriginalLength !==\r\n            //             (this as CounterPassThroughStream).bytesReceived) {\r\n\r\n            //             debug(`############### ` +\r\n            //                 `LCP zlib.createInflateRaw LENGTH NOT MATCH ` +\r\n            //                 `link.Properties.Encrypted.OriginalLength !== bytesReceived:` +\r\n            //                 `${link.Properties.Encrypted.OriginalLength} !== ` +\r\n            //                 `${(this as CounterPassThroughStream).bytesReceived}`);\r\n            //         }\r\n            //     })\r\n            //     .on(\"error\", function f() {\r\n            //         debug(\"CounterPassThroughStream ERROR: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"pipe\", function f() {\r\n            //         debug(\"CounterPassThroughStream PIPE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"unpipe\", function f() {\r\n            //         debug(\"CounterPassThroughStream UNPIPE: \" +\r\n            //             (this as CounterPassThroughStream).id);\r\n            //     })\r\n            //     .on(\"drain\", function f() {\r\n            //         // debug(\"CounterPassThroughStream DRAIN: \" +\r\n            //         //     (this as CounterPassThroughStream).id);\r\n            //     });\r\n            // destStream = counterStream;\r\n        }\r\n\r\n        const l = link.Properties.Encrypted.OriginalLength ?\r\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\r\n\r\n        if (isPartialByteRangeRequest) {\r\n            const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, l);\r\n            destStream.pipe(rangeStream);\r\n            destStream = rangeStream;\r\n            // l = partialByteLength;\r\n        }\r\n\r\n        const sal: IStreamAndLength = {\r\n            length: l,\r\n            reset: async () => {\r\n\r\n                let resetedStream: IStreamAndLength;\r\n                try {\r\n                    resetedStream = await stream.reset();\r\n                } catch (err) {\r\n                    debug(err);\r\n                    return Promise.reject(err);\r\n                }\r\n                if (!resetedStream) {\r\n                    return Promise.reject(\"??\");\r\n                }\r\n\r\n                return this.transformStream(\r\n                    publication, link,\r\n                    resetedStream,\r\n                    isPartialByteRangeRequest,\r\n                    partialByteBegin, partialByteEnd);\r\n            },\r\n            stream: destStream,\r\n        };\r\n        return Promise.resolve(sal);\r\n    }\r\n\r\n    protected async getDecryptedSizeStream(\r\n        publication: Publication, _link: Link,\r\n        stream: IStreamAndLength): Promise<ICryptoInfo> {\r\n\r\n        return new Promise<ICryptoInfo>((resolve, reject) => {\r\n\r\n            // debug(\"LCP getDecryptedSizeStream() stream.length: \" + stream.length);\r\n\r\n            // debug(\"LCP getDecryptedSizeStream() AES_BLOCK_SIZE: \" + AES_BLOCK_SIZE);\r\n\r\n            // CipherText = IV + PlainText + BLOCK - (PlainText MOD BLOCK)\r\n            // overflow: (PlainText MOD BLOCK) === PlainText - (floor(PlainText / BLOCK) * BLOCK)\r\n            // thus: CipherText = IV + BLOCK * (floor(PlainText / BLOCK) + 1)\r\n\r\n            // IV = AES_BLOCK_SIZE (first block in cyphertext)\r\n            // + at least one block\r\n            // (last one in cyphertext is either full 16-bytes random W3C padding\r\n            // in case plaintext is exactly multiple of block size,\r\n            // or partial cypher + padding)\r\n            const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\r\n            if (stream.length < TWO_AES_BLOCK_SIZE) {\r\n                reject(\"crypto err\");\r\n                return;\r\n            }\r\n            const readPos = stream.length - TWO_AES_BLOCK_SIZE;\r\n\r\n            const cypherRangeStream = new RangeStream(readPos, readPos + TWO_AES_BLOCK_SIZE - 1, stream.length);\r\n            stream.stream.pipe(cypherRangeStream);\r\n\r\n            // let buff: Buffer;\r\n            // try {\r\n            //     buff = await streamToBufferPromise(cypherRangeStream);\r\n            // } catch (err) {\r\n            //     debug(err);\r\n            //     reject(\"crypto err\");\r\n            //     return;\r\n            // }\r\n\r\n            // // debug(\"LCP getDecryptedSizeStream() buff.length: \" + buff.length);\r\n\r\n            // // // debug(buff.toString(\"hex\"));\r\n            // // for (let i = 0; i < buff.length; i++) {\r\n            // //     const b = buff[i];\r\n            // //     if (i === AES_BLOCK_SIZE) {\r\n            // //         debug(\"____\");\r\n            // //     }\r\n            // //     debug(b);\r\n            // // }\r\n\r\n            // resolve(this.getDecryptedSizeBuffer_(stream.length, buff));\r\n\r\n            const decrypteds: Buffer[] = [];\r\n\r\n            cypherRangeStream.on(\"readable\", () => {\r\n                // debug(\"readable\");\r\n\r\n                const ivBuffer = cypherRangeStream.read(AES_BLOCK_SIZE);\r\n                if (!ivBuffer) {\r\n                    // debug(\"readable null (end)\");\r\n                    return;\r\n                }\r\n\r\n                // debug(ivBuffer.toString(\"hex\"));\r\n                // e10cb2a27aa7b9633f104ccca113d499\r\n                // === asharedculture_soundtrack.mp3\r\n                //\r\n                // 5d290cb97ea83ccc01a67d30a9c7eeaa\r\n                // === shared-culture.mp4\r\n\r\n                const encrypted = cypherRangeStream.read(AES_BLOCK_SIZE);\r\n                // debug(encrypted.toString(\"hex\"));\r\n                // 14b46cb1e279d51c12ce13989b3d6cf3\r\n                // === asharedculture_soundtrack.mp3\r\n                //\r\n                // b2924b9b0cd64ab7cd349beef8e4b068\r\n                // === shared-culture.mp4\r\n\r\n                const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\r\n                    publication.LCP.ContentKey, // new Buffer(contentKey as string, \"binary\"),\r\n                    ivBuffer);\r\n                decryptStream.setAutoPadding(false);\r\n\r\n                const buff1 = decryptStream.update(encrypted);\r\n                // debug(buff1.toString(\"hex\"));\r\n                // ecf8848cb3c0c97b9e159ec2daa96810\r\n                // === asharedculture_soundtrack.mp3\r\n                //\r\n                // 004c61766635332e31372e308b6f7004\r\n                // === shared-culture.mp4\r\n                if (buff1) {\r\n                    decrypteds.push(buff1);\r\n                }\r\n\r\n                const buff2 = decryptStream.final();\r\n                // debug(buff2.toString(\"hex\"));\r\n                if (buff2) {\r\n                    decrypteds.push(buff2);\r\n                }\r\n            });\r\n\r\n            cypherRangeStream.on(\"end\", () => {\r\n                // debug(\"end\");\r\n\r\n                const decrypted = Buffer.concat(decrypteds);\r\n                // debug(decrypted.toString(\"hex\"));\r\n                // debug(decrypted.length);\r\n\r\n                const nPaddingBytes = decrypted[AES_BLOCK_SIZE - 1]; // decrypted.length = 1\r\n                // debug(nPaddingBytes);\r\n\r\n                const size = stream.length - AES_BLOCK_SIZE - nPaddingBytes;\r\n\r\n                const res: ICryptoInfo = {\r\n                    length: size,\r\n                    padding: nPaddingBytes,\r\n                };\r\n                resolve(res);\r\n            });\r\n\r\n            cypherRangeStream.on(\"error\", () => {\r\n                reject(\"DECRYPT err\");\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n    // cc-shared-culture/EPUB/audio/asharedculture_soundtrack.mp3\r\n    // 3265152 bytes\r\n    // 3 MB\r\n    // 204072 * 16 BLOCKS (inc IV)\r\n    // 3265152 MOD 16 = 0\r\n    // IV 16\r\n    // PAD 16, full extra block (random)\r\n    // + 32 = 3265184 total cypher-text\r\n\r\n    // cc-shared-culture/EPUB/video/shared-culture.mp4\r\n    // 21784780 bytes\r\n    // 21 MB\r\n    // 1361548.75 * 16 BLOCKS (inc IV)\r\n    // 21784780 MOD 16 = 12 (0.75 * 16)\r\n    // IV 16\r\n    // PAD 4 (12 cypher-text bytes in last block)\r\n    // + 20 = 21784800 total cypher-text\r\n\r\n    // cc-shared-culture/EPUB/video/shared-culture.webm\r\n    // 8330669 bytes\r\n    // 8 MB\r\n    // 520666.8125 * 16 BLOCKS (inc IV)\r\n    // 8330669 MOD 16 = 13 (0.8125 * 16)\r\n    // IV 16\r\n    // PAD 3 (13 cypher-text bytes in last block)\r\n    // + 19 = 8330688 total cypher-text\r\n"]}