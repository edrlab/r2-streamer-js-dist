{"version":3,"file":"transformer-obf-idpf.js","sourceRoot":"","sources":["../../../../src/transform/transformer-obf-idpf.ts"],"names":[],"mappings":";;;AAAA,+BAAiC;AAIjC,yDAAkF;AAKlF;IAAA;IAsEA,CAAC;IArEU,qCAAQ,GAAf,UAAgB,YAAyB,EAAE,IAAU;QACjD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,SAAS,KAAK,oCAAoC,CAAC;IACxF,CAAC;IAEY,4CAAe,GAA5B,UACI,WAAwB,EAAE,IAAU,EACpC,MAAwB,EACxB,0BAAmC,EACnC,iBAAyB,EAAE,eAAuB;;;;;;4BAErC,WAAM,mCAAqB,CAAC,MAAM,CAAC,MAAM,CAAC,EAAA;;wBAAjD,IAAI,GAAG,SAA0C;wBAC1C,WAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,EAAA;;wBAA1D,IAAI,GAAG,SAAmD;wBAE1D,GAAG,GAAqB;4BAC1B,MAAM,EAAE,IAAI,CAAC,MAAM;4BACnB,KAAK,EAAE;;oCACH,WAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAC;;iCAC/B;4BACD,MAAM,EAAE,4BAAc,CAAC,IAAI,CAAC;yBAC/B,CAAC;wBACF,WAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAAC;;;;KAC/B;IAEa,4CAAe,GAA7B,UAA8B,WAAwB,EAAE,KAAW,EAAE,IAAY;;;;gBAEzE,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC5C,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;gBAE3B,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBAC3C,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBAGjB,GAAG,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAExB,YAAY,GAAG,IAAI,CAAC;gBACpB,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;gBAElD,GAAG,CAAC,CAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,EAAE,CAAC,EAAE,EAAE,CAAC;oBAEpC,aAAa,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChE,CAAC;gBAEK,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBAClD,WAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC,CAAC,EAAC;;;KAC5E;IAyBL,yBAAC;AAAD,CAAC,AAtED,IAsEC;AAtEY,gDAAkB","sourcesContent":["import * as crypto from \"crypto\";\n\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { bufferToStream, streamToBufferPromise } from \"@utils/stream/BufferUtils\";\nimport { IStreamAndLength } from \"@utils/zip/zip\";\n\nimport { ITransformer } from \"./transformer\";\n\nexport class TransformerObfIDPF implements ITransformer {\n    public supports(_publication: Publication, link: Link): boolean {\n        return link.Properties.Encrypted.Algorithm === \"http://www.idpf.org/2008/embedding\";\n    }\n\n    public async transformStream(\n        publication: Publication, link: Link,\n        stream: IStreamAndLength,\n        _isPartialByteRangeRequest: boolean,\n        _partialByteBegin: number, _partialByteEnd: number): Promise<IStreamAndLength> {\n\n        const data = await streamToBufferPromise(stream.stream);\n        const buff = await this.transformBuffer(publication, link, data);\n\n        const sal: IStreamAndLength = {\n            length: buff.length,\n            reset: async () => {\n                return Promise.resolve(sal);\n            },\n            stream: bufferToStream(buff),\n        };\n        return Promise.resolve(sal);\n    }\n\n    private async transformBuffer(publication: Publication, _link: Link, data: Buffer): Promise<Buffer> {\n\n        let pubID = publication.Metadata.Identifier;\n        pubID = pubID.replace(/\\s/g, \"\");\n\n        const checkSum = crypto.createHash(\"sha1\");\n        checkSum.update(pubID);\n        // const hash = checkSum.digest(\"hex\");\n        // console.log(hash);\n        const key = checkSum.digest();\n\n        const prefixLength = 1040;\n        const zipDataPrefix = data.slice(0, prefixLength);\n\n        for (let i = 0; i < prefixLength; i++) {\n            /* tslint:disable:no-bitwise */\n            zipDataPrefix[i] = zipDataPrefix[i] ^ (key[i % key.length]);\n        }\n\n        const zipDataRemainder = data.slice(prefixLength);\n        return Promise.resolve(Buffer.concat([zipDataPrefix, zipDataRemainder]));\n    }\n\n    // private async getDecryptedSizeStream(\n    //     publication: Publication, link: Link,\n    //     stream: IStreamAndLength): Promise<number> {\n    //     let sal: IStreamAndLength | undefined;\n    //     try {\n    //         sal = await this.transformStream(publication, link, stream, false, 0, 0);\n    //     } catch (err) {\n    //         console.log(err);\n    //         return Promise.reject(\"WTF?\");\n    //     }\n    //     return Promise.resolve(sal.length);\n    // }\n\n    // public async getDecryptedSizeBuffer(publication: Publication, link: Link, data: Buffer): Promise<number> {\n    //     let buff: Buffer | undefined;\n    //     try {\n    //         buff = await this.transformBuffer(publication, link, data);\n    //     } catch (err) {\n    //         console.log(err);\n    //         return Promise.reject(\"WTF?\");\n    //     }\n    //     return Promise.resolve(buff.length);\n    // }\n}\n"]}