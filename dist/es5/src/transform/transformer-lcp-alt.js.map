{"version":3,"file":"transformer-lcp-alt.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp-alt.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transform } from \"stream\";\n\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { IStreamAndLength } from \"@utils/zip/zip\";\nimport * as debug_ from \"debug\";\nimport * as forge from \"node-forge\";\n\nimport { ICryptoInfo, TransformerLCP } from \"./transformer-lcp\";\n\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\n\n// import * as forge from \"node-forge\";\n// import { streamToBufferPromise } from \"@utils/stream/BufferUtils\";\n// import { RangeStream } from \"@utils/stream/RangeStream\";\n// import { ITransformer } from \"./transformer\";\n\nconst debug = debug_(\"r2:transformer:lcp\");\nconst debugx = debug_(\"r2:transformer:stream:lcp\");\n\nconst AES_BLOCK_SIZE = 16;\n\n// let streamCounter = 0;\n\nexport class TransformerLCPAlt extends TransformerLCP {\n\n    public async transformStream(\n        publication: Publication,\n        link: Link,\n        stream: IStreamAndLength,\n        isPartialByteRangeRequest: boolean,\n        partialByteBegin: number,\n        partialByteEnd: number): Promise<IStreamAndLength> {\n\n        let cryptoInfo: ICryptoInfo | undefined;\n        let plainTextSize = -1;\n        let cypherBlockPadding = -1;\n        if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n            plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n            cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\n        } else {\n            // const timeBegin = process.hrtime();\n\n            cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\n            plainTextSize = cryptoInfo.length;\n            cypherBlockPadding = cryptoInfo.padding;\n\n            // length cached to avoid resetting the stream to zero-position\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n            link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\n\n            stream = await stream.reset();\n\n            // const timeElapsed = process.hrtime(timeBegin);\n            // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\n            //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\n\n            // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n\n            if (link.Properties.Encrypted.OriginalLength &&\n                link.Properties.Encrypted.Compression === \"none\" &&\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\n\n                debug(`############### ` +\n                    `LCP transformStream() LENGTH NOT MATCH ` +\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize:` +\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\n            }\n        }\n\n        if (partialByteBegin < 0) {\n            partialByteBegin = 0;\n        }\n\n        if (partialByteEnd < 0) {\n            partialByteEnd = plainTextSize - 1;\n            if (link.Properties.Encrypted.OriginalLength) {\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\n            }\n        }\n\n        const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n        // block padding scheme\n        let padding = false; // NO_PADDING\n        const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\n\n        // debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\n\n        if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\n            padding = true; // W3C_PADDING, also PKCS#7\n        }\n\n        // byte offset in first block of the cypher text that contains the range begin\n        const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\n\n        // we read the entire first block, even if partially used\n        const readPosition = partialByteBegin - blockOffset;\n\n        // debug(\"LCP transformStream() blockOffset: \" + blockOffset);\n        // debug(\"LCP transformStream() readPosition: \" + readPosition);\n\n        // number of blocks to read\n        let blocksCount = 1;\n        let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\n\n        // debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\n\n        if (partialByteLength < bytesInFirstBlock) {\n            bytesInFirstBlock = 0;\n        }\n        if (bytesInFirstBlock > 0) {\n            blocksCount++;\n        }\n\n        const diff = partialByteLength - bytesInFirstBlock;\n\n        // debug(\"LCP transformStream() diff: \" + diff);\n\n        let inc = diff / AES_BLOCK_SIZE;\n        // debug(\"LCP transformStream() inc: \" + inc);\n\n        inc = Math.floor(inc);\n        // debug(\"LCP transformStream() inc: \" + inc);\n\n        blocksCount += inc;\n\n        const rem = diff % AES_BLOCK_SIZE;\n        // debug(\"LCP transformStream() rem: \" + rem);\n\n        if (rem !== 0) {\n            blocksCount++;\n        }\n\n        // debug(\"LCP transformStream() blocksCount: \" + blocksCount);\n\n        // number of bytes to read (block aligned)\n        const toRead = blocksCount * AES_BLOCK_SIZE;\n\n        const readPositionEND = readPosition + toRead - 1;\n\n        // const rangeStream = new RangeStream(readPosition, readPositionEND, stream.length);\n        const decryptStreamStreamBegin = readPosition;\n        const decryptStreamStreamEnd = readPositionEND;\n\n        const decryptStreamBlockOffset = blockOffset;\n\n        let decryptStreamBytesReceived = 0;\n        let decryptStreamBytesSent = 0;\n        let decryptStreamFinished = false;\n        let decryptStreamClosed = false;\n        let decryptStreamFirst = true;\n\n        const decryptStreamThis = this;\n\n        let decryptStreamBuffers: Buffer[] = [];\n\n        const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n\n        const decryptStream = new Transform({\n            flush(callback: () => void): void {\n                debugx(\"LcpDecryptStream FLUSH\");\n\n                let toDecrypt: Buffer | undefined;\n\n                let decryptStreamBuffersTotalLength = 0;\n                decryptStreamBuffers.forEach((buff) => {\n                    decryptStreamBuffersTotalLength += buff.length;\n                });\n                if (decryptStreamBuffersTotalLength) {\n\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBuffersTotalLength: \" +\n                        decryptStreamBuffersTotalLength);\n\n                    const available = decryptStreamBuffersTotalLength;\n\n                    if (available === TWO_AES_BLOCK_SIZE) {\n                        toDecrypt = Buffer.concat(decryptStreamBuffers);\n                        decryptStreamBuffers = [];\n                    } else if (available < TWO_AES_BLOCK_SIZE) {\n                        debugx(\"LcpDecryptStream NOT ENOUGH DATA????\");\n                    } else { // available > TWO_AES_BLOCK_SIZE\n\n                        const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\n                        decryptStreamBuffers = [];\n\n                        const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\n                        const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                        // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\n                        if (blocksBytes === decryptStreamBuffersConcat.length) {\n                            toDecrypt = decryptStreamBuffersConcat;\n                        } else {\n                            debugx(\"LcpDecryptStream OVERFLOW DATA????\");\n                            // toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\n                            // decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\n                        }\n                    }\n                }\n\n                if (toDecrypt) {\n                    let newBuff = decryptStreamThis.innerDecrypt(\n                        publication,\n                        link,\n                        toDecrypt,\n                        padding);\n                    if (decryptStreamFirst) {\n                        decryptStreamFirst = false;\n                        newBuff = newBuff.slice(decryptStreamBlockOffset);\n                    }\n                    decryptStreamBytesSent += newBuff.length;\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBytesSent: \" + decryptStreamBytesSent);\n                    this.push(newBuff);\n                }\n\n                if (decryptStreamBytesSent !== plainTextSize) {\n\n                    debugx(`############### ` +\n                        `LcpDecryptStream FLUSH  LENGTH NOT MATCH ` +\n                        `decryptStreamBytesSent !== plainTextSize:` +\n                        `[ ${decryptStreamStreamBegin} (${decryptStreamStreamEnd}) ] ` +\n                        `${decryptStreamBytesReceived} (${stream.length}) > ` +\n                        `${decryptStreamBytesSent} !== ${plainTextSize}`);\n                }\n                callback();\n            },\n\n            transform(chunk: Buffer, _encoding: string, callback: () => void): void {\n                decryptStreamBytesReceived += chunk.length;\n\n                debugx(\"TRANSFORM chunk.length: \" + chunk.length + \" (( \" + decryptStreamBytesReceived);\n\n                if (decryptStreamFinished) {\n                    if (!decryptStreamClosed) {\n                        debugx(\"???? LcpDecryptStream CLOSING...\");\n                        decryptStreamClosed = true;\n                        this.push(null);\n                    } else {\n                        debugx(\"???? LcpDecryptStream STILL PIPE CALLING _transform ??!\");\n                        this.end();\n                    }\n                } else {\n                    if (decryptStreamBytesReceived > decryptStreamStreamBegin) {\n\n                        let chunkBegin = 0;\n                        let chunkEnd = chunk.length - 1;\n\n                        chunkBegin = decryptStreamStreamBegin - (decryptStreamBytesReceived - chunk.length);\n                        if (chunkBegin < 0) {\n                            chunkBegin = 0;\n                        }\n\n                        if (decryptStreamBytesReceived > decryptStreamStreamEnd) {\n                            decryptStreamFinished = true;\n\n                            const decr = decryptStreamBytesReceived - decryptStreamStreamEnd;\n\n                            debugx(\"LcpDecryptStream TRANSFORM FINISH decr: \" + decr);\n\n                            chunkEnd = chunk.length - decr;\n                        }\n\n                        debugx(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\n\n                        const encryptedChunk = chunk.slice(chunkBegin, chunkEnd + 1);\n\n                        let toDecrypt: Buffer | undefined;\n\n                        let decryptStreamBuffersTotalLength = 0;\n                        decryptStreamBuffers.forEach((buff) => {\n                            decryptStreamBuffersTotalLength += buff.length;\n                        });\n                        if (decryptStreamBuffersTotalLength) {\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBuffersTotalLength: \" +\n                                decryptStreamBuffersTotalLength);\n\n                            const available = decryptStreamBuffersTotalLength + encryptedChunk.length;\n\n                            if (available === TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                                toDecrypt = Buffer.concat(decryptStreamBuffers);\n                                decryptStreamBuffers = [];\n                            } else if (available < TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                            } else { // available > TWO_AES_BLOCK_SIZE\n                                decryptStreamBuffers.push(encryptedChunk);\n                                const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\n                                decryptStreamBuffers = [];\n\n                                const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                                // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\n                                if (blocksBytes === decryptStreamBuffersConcat.length) {\n                                    toDecrypt = decryptStreamBuffersConcat;\n                                } else {\n                                    toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\n                                    decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\n                                }\n                            }\n                        } else {\n                            if (encryptedChunk.length === TWO_AES_BLOCK_SIZE) {\n                                toDecrypt = encryptedChunk;\n                            } else if (encryptedChunk.length < TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                            } else { // encryptedChunk.length > TWO_AES_BLOCK_SIZE\n                                const nBlocks = Math.floor(encryptedChunk.length / AES_BLOCK_SIZE);\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                                // encryptedChunk.length % AES_BLOCK_SIZE === 0\n                                if (blocksBytes === encryptedChunk.length) {\n                                    toDecrypt = encryptedChunk;\n                                } else {\n                                    toDecrypt = encryptedChunk.slice(0, blocksBytes);\n                                    decryptStreamBuffers.push(encryptedChunk.slice(blocksBytes));\n                                }\n                            }\n                        }\n\n                        if (toDecrypt) {\n\n                            debugx(`CHUNK TO DECRYPT: ${toDecrypt.length}`);\n\n                            let newBuff = decryptStreamThis.innerDecrypt(\n                                publication,\n                                link,\n                                toDecrypt,\n                                decryptStreamFinished ? padding : false);\n\n                            debugx(`CHUNK DECRYPTED: ${newBuff.length}`);\n\n                            if (decryptStreamFirst) {\n                                decryptStreamFirst = false;\n                                debugx(\"LcpDecryptStream TRANSFORM decryptStreamBlockOffset: \" +\n                                    decryptStreamBlockOffset);\n                                newBuff = newBuff.slice(decryptStreamBlockOffset);\n                            }\n                            decryptStreamBytesSent += newBuff.length;\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBytesSent: \" + decryptStreamBytesSent);\n                            this.push(newBuff);\n                        }\n\n                        if (decryptStreamFinished) {\n                            debugx(\"LcpDecryptStream FINISHING...\");\n                            decryptStreamClosed = true;\n                            this.push(null);\n                            this.end();\n                        }\n                    } else {\n                        // NOOP\n                        // no call to this.push(), we skip the entire current chunk buffer\n                    }\n                }\n\n                callback();\n            },\n        });\n\n        const l = link.Properties.Encrypted.OriginalLength ?\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\n\n        const sal: IStreamAndLength = {\n            length: l,\n            reset: async () => {\n                const resetedStream = await stream.reset();\n                return this.transformStream(\n                    publication, link,\n                    resetedStream,\n                    isPartialByteRangeRequest,\n                    partialByteBegin, partialByteEnd);\n            },\n            stream: decryptStream,\n        };\n        return Promise.resolve(sal);\n    }\n\n    // private async transformStream__(\n    //     publication: Publication, link: Link,\n    //     stream: IStreamAndLength,\n    //     isPartialByteRangeRequest: boolean,\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\n\n    //     if (!isPartialByteRangeRequest) {\n    //         return this.transformStream_(\n    //             publication, link,\n    //             stream,\n    //             isPartialByteRangeRequest,\n    //             partialByteBegin, partialByteEnd);\n    //     }\n\n    //     debug(\"LCP transformStream() RAW STREAM LENGTH: \" + stream.length);\n\n    //     let plainTextSize = -1;\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n    //         plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n    //     } else {\n    //         plainTextSize = await this.getDecryptedSizeStream(publication, link, stream);\n    //         debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n    //         stream = await stream.reset();\n    //         // length cached to avoid resetting the stream to zero-position\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n    //     }\n    //     debug(\"LCP transformStream() plainTextSize: \" + plainTextSize);\n\n    //     if (partialByteBegin < 0) {\n    //         partialByteBegin = 0;\n    //     }\n\n    //     if (partialByteEnd < 0) {\n    //         partialByteEnd = plainTextSize - 1;\n    //         if (link.Properties.Encrypted.OriginalLength) {\n    //             partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\n    //         }\n    //     }\n\n    //     const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n    //     debug(\"LCP transformStream() partialByteBegin: \" + partialByteBegin);\n    //     debug(\"LCP transformStream() partialByteEnd: \" + partialByteEnd);\n    //     debug(\"LCP transformStream() partialByteLength: \" + partialByteLength);\n\n    //     // block padding scheme\n    //     let padding = false; // NO_PADDING\n    //     const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\n\n    //     debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\n\n    //     if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\n    //         padding = true; // W3C_PADDING, also PKCS#7\n    //     }\n\n    //     // byte offset in first block of the cypher text that contains the range begin\n    //     const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\n\n    //     // we read the entire first block, even if partially used\n    //     const readPosition = partialByteBegin - blockOffset;\n\n    //     debug(\"LCP transformStream() blockOffset: \" + blockOffset);\n    //     debug(\"LCP transformStream() readPosition: \" + readPosition);\n\n    //     // number of blocks to read\n    //     let blocksCount = 1;\n    //     let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\n\n    //     debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\n\n    //     if (partialByteLength < bytesInFirstBlock) {\n    //         bytesInFirstBlock = 0;\n    //     }\n    //     if (bytesInFirstBlock > 0) {\n    //         blocksCount++;\n    //     }\n\n    //     const diff = partialByteLength - bytesInFirstBlock;\n\n    //     debug(\"LCP transformStream() diff: \" + diff);\n\n    //     let inc = diff / AES_BLOCK_SIZE;\n    //     debug(\"LCP transformStream() inc: \" + inc);\n\n    //     inc = Math.floor(inc);\n    //     debug(\"LCP transformStream() inc: \" + inc);\n\n    //     blocksCount += inc;\n\n    //     const rem = diff % AES_BLOCK_SIZE;\n    //     debug(\"LCP transformStream() rem: \" + rem);\n\n    //     if (rem !== 0) {\n    //         blocksCount++;\n    //     }\n\n    //     debug(\"LCP transformStream() blocksCount: \" + blocksCount);\n\n    //     // number of bytes to read (block aligned)\n    //     const toRead = blocksCount * AES_BLOCK_SIZE;\n\n    //     debug(\"LCP transformStream() toRead: \" + toRead);\n\n    //     const rangeStream = new RangeStream(readPosition, readPosition + toRead - 1, stream.length);\n    //     stream.stream.pipe(rangeStream);\n    //     let buff: Buffer;\n    //     try {\n    //         buff = await streamToBufferPromise(rangeStream);\n    //     } catch (err) {\n    //         debug(err);\n    //         return Promise.reject(\"OUCH!\");\n    //     }\n\n    //     debug(\"LCP transformStream() buff.length: \" + buff.length);\n\n    //     let newBuff = this.innerDecrypt(buff, padding);\n\n    //     debug(\"LCP transformStream() newBuff.length: \" + newBuff.length);\n\n    //     if (newBuff.length < partialByteLength) {\n    //         debug(\"newBuff.length < partialByteLength\");\n    //     }\n    //     newBuff = newBuff.slice(blockOffset);\n\n    //     debug(\"LCP transformStream() newBuff.length (blockOffset): \" + newBuff.length);\n\n    //     const bufferStream = bufferToStream(newBuff);\n\n    //     const sal: IStreamAndLength = {\n    //         length: plainTextSize, // newBuff.length,\n    //         reset: async () => {\n    //             const resetedStream = await stream.reset();\n    //             return this.transformStream(\n    //                 publication, link,\n    //                 resetedStream,\n    //                 isPartialByteRangeRequest,\n    //                 partialByteBegin, partialByteEnd);\n    //         },\n    //         stream: bufferStream,\n    //     };\n    //     return Promise.resolve(sal);\n    // }\n\n    // private async transformStream_(\n    //     publication: Publication, link: Link,\n    //     stream: IStreamAndLength,\n    //     isPartialByteRangeRequest: boolean,\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\n\n    //     debug(\"LCP transformStream_() RAW STREAM LENGTH: \" + stream.length);\n\n    //     let l = -1;\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n    //         l = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n    //     } else {\n    //         l = await this.getDecryptedSizeStream(publication, link, stream);\n    //         debug(\"LCP transformStream_() ---- getDecryptedSizeStream(): \" + l);\n    //         stream = await stream.reset();\n    //         // length cached to avoid resetting the stream to zero-position\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = l;\n    //     }\n\n    //     const data = await streamToBufferPromise(stream.stream);\n    //     debug(\"LCP transformStream_() RAW BUFFER LENGTH after reset: \" + stream.length);\n    //     const buff = await this.transformBuffer(publication, link, data);\n    //     debug(\"LCP transformStream_() DECRYPTED BUFFER LENGTH: \" + buff.length);\n\n    //     if (partialByteBegin < 0) {\n    //         partialByteBegin = 0;\n    //     }\n    //     if (partialByteEnd < 0) {\n    //         partialByteEnd = buff.length - 1;\n    //     }\n\n    //     if (isPartialByteRangeRequest) {\n    //         debug(\"LCP transformStream_() PARTIAL: \" + partialByteBegin + \" - \" + partialByteEnd);\n\n    //         const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, buff.length);\n    //         const bufferStream = bufferToStream(buff);\n    //         bufferStream.pipe(rangeStream);\n\n    //         const sal: IStreamAndLength = {\n    //             length: buff.length, // (partialByteEnd + 1) - partialByteBegin,\n    //             reset: async () => {\n    //                 const resetedStream = await stream.reset();\n    //                 return this.transformStream(\n    //                     publication, link,\n    //                     resetedStream,\n    //                     isPartialByteRangeRequest,\n    //                     partialByteBegin, partialByteEnd);\n    //             },\n    //             stream: rangeStream,\n    //         };\n    //         return Promise.resolve(sal);\n    //     } else {\n    //         debug(\"LCP transformStream_() WHOLE: \" + buff.length);\n\n    //         const sal: IStreamAndLength = {\n    //             length: buff.length,\n    //             reset: async () => {\n    //                 return Promise.resolve(sal);\n    //             },\n    //             stream: bufferToStream(buff),\n    //         };\n    //         return Promise.resolve(sal);\n    //     }\n    // }\n\n    // private async getDecryptedSizeBuffer(_publication: Publication, _link: Link, data: Buffer): Promise<number> {\n\n    //     const totalByteLength = data.length;\n\n    //     const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n    //     if (totalByteLength < TWO_AES_BLOCK_SIZE) {\n    //         return 0;\n    //     }\n    //     const readPos = totalByteLength - TWO_AES_BLOCK_SIZE;\n\n    //     const buff = data.slice(readPos, totalByteLength);\n\n    //     return this.getDecryptedSizeBuffer_(totalByteLength, buff);\n    // }\n\n    protected innerDecrypt(\n        publication: Publication, _link: Link,\n        data: Buffer, padding: boolean): Buffer {\n        // debug(\"LCP innerDecrypt() data.length: \" + data.length);\n        // debug(\"LCP innerDecrypt() padding: \" + padding);\n\n        const contentKey = publication.LCP.ContentKey;\n\n        const buffIV = data.slice(0, AES_BLOCK_SIZE);\n        // debug(\"LCP innerDecrypt() buffIV.length: \" + buffIV.length);\n\n        // TODO: keep buffer to avoid costly string conversion?\n        const iv = buffIV.toString(\"binary\");\n\n        const buffToDecrypt = data.slice(AES_BLOCK_SIZE);\n        // debug(\"LCP innerDecrypt() buffToDecrypt: \" + buffToDecrypt.length);\n\n        // TODO: keep buffer to avoid costly string conversion?\n        const strToDecrypt = buffToDecrypt.toString(\"binary\");\n        const toDecrypt =\n            forge.util.createBuffer(strToDecrypt, \"binary\");\n\n        const aesCbcDecipher = (forge as any).cipher.createDecipher(\"AES-CBC\", contentKey);\n        aesCbcDecipher.start({ iv, additionalData_: \"binary-encoded string\" });\n        aesCbcDecipher.update(toDecrypt);\n\n        function unpadFunc() { return false; }\n        // const res =\n        aesCbcDecipher.finish(padding ? undefined : unpadFunc);\n        // debug(res);\n\n        const decryptedZipData = aesCbcDecipher.output.bytes();\n\n        // debug(forge.util.bytesToHex(decryptedZipData));\n        // debug(decryptedZipData.toHex());\n\n        const buff = new Buffer(decryptedZipData, \"binary\");\n\n        // debug(\"LCP innerDecrypt() buff.length: \" + buff.length);\n\n        return buff;\n    }\n\n    // protected async getDecryptedSizeBuffer_(totalByteLength: number, buff: Buffer): Promise<ICryptoInfo> {\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() totalByteLength: \" + totalByteLength);\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() buff.length: \" + buff.length);\n\n    //     const padding = true;\n    //     const newBuff = this.innerDecrypt(buff, padding);\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() newBuff.length (innerDecrypt): \" + newBuff.length);\n\n    //     // newBuff.length === 0\n    //     // when last second block is all padding,\n    //     // otherwise newBuff.length === overflow encrypted bytes,\n    //     // number between [1, AES_BLOCK_SIZE[\n    //     const nPaddingBytes = padding ? (AES_BLOCK_SIZE - newBuff.length) : newBuff[15];\n    //     // debugx(\"LCP getDecryptedSizeBuffer_() nPaddingBytes: \" + nPaddingBytes);\n\n    //     const size = totalByteLength - AES_BLOCK_SIZE - nPaddingBytes;\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() size: \" + size);\n\n    //     const res: ICryptoInfo = {\n    //         length: size,\n    //         padding: nPaddingBytes,\n    //     };\n\n    //     return Promise.resolve(res);\n    // }\n\n    // private async transformBuffer(_publication: Publication, link: Link, data: Buffer): Promise<Buffer> {\n\n    //     const l = await this.getDecryptedSizeBuffer(_publication, link, data);\n    //     debug(\"LCP transformBuffer() ==== decrypted buffer length CHECK: \" + l);\n\n    //     let transformedData = this.innerDecrypt(data, true);\n\n    //     debug(\"LCP transformBuffer() decrypted buffer length before INFLATE: \" + transformedData.length);\n\n    //     if (link.Properties.Encrypted.Compression === \"deflate\") {\n    //         transformedData = zlib.inflateRawSync(transformedData);\n    //     }\n\n    //     debug(\"LCP transformBuffer() decrypted buffer length after INFLATE: \" + transformedData.length);\n\n    //     if (link.Properties.Encrypted.OriginalLength\n    //         && link.Properties.Encrypted.OriginalLength !== transformedData.length) {\n    //         debug(`LENGTH NOT MATCH ${link.Properties.Encrypted.OriginalLength} !== ${transformedData.length}`);\n    //     }\n\n    //     return Promise.resolve(transformedData);\n    // }\n}\n"]}