{"version":3,"file":"transformer-lcp-alt.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp-alt.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transform } from \"stream\";\r\n\r\nimport { Publication } from \"@models/publication\";\r\nimport { Link } from \"@models/publication-link\";\r\nimport { IStreamAndLength } from \"@utils/zip/zip\";\r\nimport * as debug_ from \"debug\";\r\nimport * as forge from \"node-forge\";\r\n\r\nimport { ICryptoInfo, TransformerLCP } from \"./transformer-lcp\";\r\n\r\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\r\n\r\n// import * as forge from \"node-forge\";\r\n// import { streamToBufferPromise } from \"@utils/stream/BufferUtils\";\r\n// import { RangeStream } from \"@utils/stream/RangeStream\";\r\n// import { ITransformer } from \"./transformer\";\r\n\r\nconst debug = debug_(\"r2:transformer:lcp\");\r\nconst debugx = debug_(\"r2:transformer:stream:lcp\");\r\n\r\nconst AES_BLOCK_SIZE = 16;\r\n\r\n// let streamCounter = 0;\r\n\r\nexport class TransformerLCPAlt extends TransformerLCP {\r\n\r\n    public async transformStream(\r\n        publication: Publication,\r\n        link: Link,\r\n        stream: IStreamAndLength,\r\n        isPartialByteRangeRequest: boolean,\r\n        partialByteBegin: number,\r\n        partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n        let cryptoInfo: ICryptoInfo | undefined;\r\n        let plainTextSize = -1;\r\n        let cypherBlockPadding = -1;\r\n        if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n            plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n            cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\r\n        } else {\r\n            // const timeBegin = process.hrtime();\r\n\r\n            cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\r\n            plainTextSize = cryptoInfo.length;\r\n            cypherBlockPadding = cryptoInfo.padding;\r\n\r\n            // length cached to avoid resetting the stream to zero-position\r\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n            link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\r\n\r\n            stream = await stream.reset();\r\n\r\n            // const timeElapsed = process.hrtime(timeBegin);\r\n            // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\r\n            //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\r\n\r\n            // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\r\n\r\n            if (link.Properties.Encrypted.OriginalLength &&\r\n                link.Properties.Encrypted.Compression === \"none\" &&\r\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\r\n\r\n                debug(`############### ` +\r\n                    `LCP transformStream() LENGTH NOT MATCH ` +\r\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize:` +\r\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\r\n            }\r\n        }\r\n\r\n        if (partialByteBegin < 0) {\r\n            partialByteBegin = 0;\r\n        }\r\n\r\n        if (partialByteEnd < 0) {\r\n            partialByteEnd = plainTextSize - 1;\r\n            if (link.Properties.Encrypted.OriginalLength) {\r\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\r\n            }\r\n        }\r\n\r\n        const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\r\n\r\n        // block padding scheme\r\n        let padding = false; // NO_PADDING\r\n        const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\r\n\r\n        // debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\r\n\r\n        if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\r\n            padding = true; // W3C_PADDING, also PKCS#7\r\n        }\r\n\r\n        // byte offset in first block of the cypher text that contains the range begin\r\n        const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\r\n\r\n        // we read the entire first block, even if partially used\r\n        const readPosition = partialByteBegin - blockOffset;\r\n\r\n        // debug(\"LCP transformStream() blockOffset: \" + blockOffset);\r\n        // debug(\"LCP transformStream() readPosition: \" + readPosition);\r\n\r\n        // number of blocks to read\r\n        let blocksCount = 1;\r\n        let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\r\n\r\n        // debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\r\n\r\n        if (partialByteLength < bytesInFirstBlock) {\r\n            bytesInFirstBlock = 0;\r\n        }\r\n        if (bytesInFirstBlock > 0) {\r\n            blocksCount++;\r\n        }\r\n\r\n        const diff = partialByteLength - bytesInFirstBlock;\r\n\r\n        // debug(\"LCP transformStream() diff: \" + diff);\r\n\r\n        let inc = diff / AES_BLOCK_SIZE;\r\n        // debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n        inc = Math.floor(inc);\r\n        // debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n        blocksCount += inc;\r\n\r\n        const rem = diff % AES_BLOCK_SIZE;\r\n        // debug(\"LCP transformStream() rem: \" + rem);\r\n\r\n        if (rem !== 0) {\r\n            blocksCount++;\r\n        }\r\n\r\n        // debug(\"LCP transformStream() blocksCount: \" + blocksCount);\r\n\r\n        // number of bytes to read (block aligned)\r\n        const toRead = blocksCount * AES_BLOCK_SIZE;\r\n\r\n        const readPositionEND = readPosition + toRead - 1;\r\n\r\n        // const rangeStream = new RangeStream(readPosition, readPositionEND, stream.length);\r\n        const decryptStreamStreamBegin = readPosition;\r\n        const decryptStreamStreamEnd = readPositionEND;\r\n\r\n        const decryptStreamBlockOffset = blockOffset;\r\n\r\n        let decryptStreamBytesReceived = 0;\r\n        let decryptStreamBytesSent = 0;\r\n        let decryptStreamFinished = false;\r\n        let decryptStreamClosed = false;\r\n        let decryptStreamFirst = true;\r\n\r\n        const decryptStreamThis = this;\r\n\r\n        let decryptStreamBuffers: Buffer[] = [];\r\n\r\n        const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\r\n\r\n        // @ts-ignore: TS2345 strictFunctionTypes\r\n        const decryptStream = new Transform({\r\n            flush(callback: () => void): void {\r\n                debugx(\"LcpDecryptStream FLUSH\");\r\n\r\n                let toDecrypt: Buffer | undefined;\r\n\r\n                let decryptStreamBuffersTotalLength = 0;\r\n                decryptStreamBuffers.forEach((buff) => {\r\n                    decryptStreamBuffersTotalLength += buff.length;\r\n                });\r\n                if (decryptStreamBuffersTotalLength) {\r\n\r\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBuffersTotalLength: \" +\r\n                        decryptStreamBuffersTotalLength);\r\n\r\n                    const available = decryptStreamBuffersTotalLength;\r\n\r\n                    if (available === TWO_AES_BLOCK_SIZE) {\r\n                        toDecrypt = Buffer.concat(decryptStreamBuffers);\r\n                        decryptStreamBuffers = [];\r\n                    } else if (available < TWO_AES_BLOCK_SIZE) {\r\n                        debugx(\"LcpDecryptStream NOT ENOUGH DATA????\");\r\n                    } else { // available > TWO_AES_BLOCK_SIZE\r\n\r\n                        const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\r\n                        decryptStreamBuffers = [];\r\n\r\n                        const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\r\n                        const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                        // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\r\n                        if (blocksBytes === decryptStreamBuffersConcat.length) {\r\n                            toDecrypt = decryptStreamBuffersConcat;\r\n                        } else {\r\n                            debugx(\"LcpDecryptStream OVERFLOW DATA????\");\r\n                            // toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\r\n                            // decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (toDecrypt) {\r\n                    let newBuff = decryptStreamThis.innerDecrypt(\r\n                        publication,\r\n                        link,\r\n                        toDecrypt,\r\n                        padding);\r\n                    if (decryptStreamFirst) {\r\n                        decryptStreamFirst = false;\r\n                        newBuff = newBuff.slice(decryptStreamBlockOffset);\r\n                    }\r\n                    decryptStreamBytesSent += newBuff.length;\r\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBytesSent: \" + decryptStreamBytesSent);\r\n                    decryptStream.push(newBuff);\r\n                }\r\n\r\n                if (decryptStreamBytesSent !== plainTextSize) {\r\n\r\n                    debugx(`############### ` +\r\n                        `LcpDecryptStream FLUSH  LENGTH NOT MATCH ` +\r\n                        `decryptStreamBytesSent !== plainTextSize:` +\r\n                        `[ ${decryptStreamStreamBegin} (${decryptStreamStreamEnd}) ] ` +\r\n                        `${decryptStreamBytesReceived} (${stream.length}) > ` +\r\n                        `${decryptStreamBytesSent} !== ${plainTextSize}`);\r\n                }\r\n                callback();\r\n            },\r\n\r\n            transform(chunk: Buffer, _encoding: string, callback: () => void): void {\r\n                decryptStreamBytesReceived += chunk.length;\r\n\r\n                debugx(\"TRANSFORM chunk.length: \" + chunk.length + \" (( \" + decryptStreamBytesReceived);\r\n\r\n                if (decryptStreamFinished) {\r\n                    if (!decryptStreamClosed) {\r\n                        debugx(\"???? LcpDecryptStream CLOSING...\");\r\n                        decryptStreamClosed = true;\r\n                        decryptStream.push(null);\r\n                    } else {\r\n                        debugx(\"???? LcpDecryptStream STILL PIPE CALLING _transform ??!\");\r\n                        decryptStream.end();\r\n                    }\r\n                } else {\r\n                    if (decryptStreamBytesReceived > decryptStreamStreamBegin) {\r\n\r\n                        let chunkBegin = 0;\r\n                        let chunkEnd = chunk.length - 1;\r\n\r\n                        chunkBegin = decryptStreamStreamBegin - (decryptStreamBytesReceived - chunk.length);\r\n                        if (chunkBegin < 0) {\r\n                            chunkBegin = 0;\r\n                        }\r\n\r\n                        if (decryptStreamBytesReceived > decryptStreamStreamEnd) {\r\n                            decryptStreamFinished = true;\r\n\r\n                            const decr = decryptStreamBytesReceived - decryptStreamStreamEnd;\r\n\r\n                            debugx(\"LcpDecryptStream TRANSFORM FINISH decr: \" + decr);\r\n\r\n                            chunkEnd = chunk.length - decr;\r\n                        }\r\n\r\n                        debugx(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\r\n\r\n                        const encryptedChunk = chunk.slice(chunkBegin, chunkEnd + 1);\r\n\r\n                        let toDecrypt: Buffer | undefined;\r\n\r\n                        let decryptStreamBuffersTotalLength = 0;\r\n                        decryptStreamBuffers.forEach((buff) => {\r\n                            decryptStreamBuffersTotalLength += buff.length;\r\n                        });\r\n                        if (decryptStreamBuffersTotalLength) {\r\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBuffersTotalLength: \" +\r\n                                decryptStreamBuffersTotalLength);\r\n\r\n                            const available = decryptStreamBuffersTotalLength + encryptedChunk.length;\r\n\r\n                            if (available === TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                                toDecrypt = Buffer.concat(decryptStreamBuffers);\r\n                                decryptStreamBuffers = [];\r\n                            } else if (available < TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                            } else { // available > TWO_AES_BLOCK_SIZE\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                                const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\r\n                                decryptStreamBuffers = [];\r\n\r\n                                const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\r\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                                // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\r\n                                if (blocksBytes === decryptStreamBuffersConcat.length) {\r\n                                    toDecrypt = decryptStreamBuffersConcat;\r\n                                } else {\r\n                                    toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\r\n                                    decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (encryptedChunk.length === TWO_AES_BLOCK_SIZE) {\r\n                                toDecrypt = encryptedChunk;\r\n                            } else if (encryptedChunk.length < TWO_AES_BLOCK_SIZE) {\r\n                                decryptStreamBuffers.push(encryptedChunk);\r\n                            } else { // encryptedChunk.length > TWO_AES_BLOCK_SIZE\r\n                                const nBlocks = Math.floor(encryptedChunk.length / AES_BLOCK_SIZE);\r\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\r\n\r\n                                // encryptedChunk.length % AES_BLOCK_SIZE === 0\r\n                                if (blocksBytes === encryptedChunk.length) {\r\n                                    toDecrypt = encryptedChunk;\r\n                                } else {\r\n                                    toDecrypt = encryptedChunk.slice(0, blocksBytes);\r\n                                    decryptStreamBuffers.push(encryptedChunk.slice(blocksBytes));\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (toDecrypt) {\r\n\r\n                            debugx(`CHUNK TO DECRYPT: ${toDecrypt.length}`);\r\n\r\n                            let newBuff = decryptStreamThis.innerDecrypt(\r\n                                publication,\r\n                                link,\r\n                                toDecrypt,\r\n                                decryptStreamFinished ? padding : false);\r\n\r\n                            debugx(`CHUNK DECRYPTED: ${newBuff.length}`);\r\n\r\n                            if (decryptStreamFirst) {\r\n                                decryptStreamFirst = false;\r\n                                debugx(\"LcpDecryptStream TRANSFORM decryptStreamBlockOffset: \" +\r\n                                    decryptStreamBlockOffset);\r\n                                newBuff = newBuff.slice(decryptStreamBlockOffset);\r\n                            }\r\n                            decryptStreamBytesSent += newBuff.length;\r\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBytesSent: \" + decryptStreamBytesSent);\r\n                            decryptStream.push(newBuff);\r\n                        }\r\n\r\n                        if (decryptStreamFinished) {\r\n                            debugx(\"LcpDecryptStream FINISHING...\");\r\n                            decryptStreamClosed = true;\r\n                            decryptStream.push(null);\r\n                            decryptStream.end();\r\n                        }\r\n                    } else {\r\n                        // NOOP\r\n                        // no call to this.push(), we skip the entire current chunk buffer\r\n                    }\r\n                }\r\n\r\n                callback();\r\n            },\r\n        });\r\n\r\n        const l = link.Properties.Encrypted.OriginalLength ?\r\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\r\n\r\n        const sal: IStreamAndLength = {\r\n            length: l,\r\n            reset: async () => {\r\n                const resetedStream = await stream.reset();\r\n                return this.transformStream(\r\n                    publication, link,\r\n                    resetedStream,\r\n                    isPartialByteRangeRequest,\r\n                    partialByteBegin, partialByteEnd);\r\n            },\r\n            stream: decryptStream,\r\n        };\r\n        return Promise.resolve(sal);\r\n    }\r\n\r\n    // private async transformStream__(\r\n    //     publication: Publication, link: Link,\r\n    //     stream: IStreamAndLength,\r\n    //     isPartialByteRangeRequest: boolean,\r\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n    //     if (!isPartialByteRangeRequest) {\r\n    //         return this.transformStream_(\r\n    //             publication, link,\r\n    //             stream,\r\n    //             isPartialByteRangeRequest,\r\n    //             partialByteBegin, partialByteEnd);\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() RAW STREAM LENGTH: \" + stream.length);\r\n\r\n    //     let plainTextSize = -1;\r\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n    //         plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n    //     } else {\r\n    //         plainTextSize = await this.getDecryptedSizeStream(publication, link, stream);\r\n    //         debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\r\n    //         stream = await stream.reset();\r\n    //         // length cached to avoid resetting the stream to zero-position\r\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\r\n    //     }\r\n    //     debug(\"LCP transformStream() plainTextSize: \" + plainTextSize);\r\n\r\n    //     if (partialByteBegin < 0) {\r\n    //         partialByteBegin = 0;\r\n    //     }\r\n\r\n    //     if (partialByteEnd < 0) {\r\n    //         partialByteEnd = plainTextSize - 1;\r\n    //         if (link.Properties.Encrypted.OriginalLength) {\r\n    //             partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\r\n    //         }\r\n    //     }\r\n\r\n    //     const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\r\n\r\n    //     debug(\"LCP transformStream() partialByteBegin: \" + partialByteBegin);\r\n    //     debug(\"LCP transformStream() partialByteEnd: \" + partialByteEnd);\r\n    //     debug(\"LCP transformStream() partialByteLength: \" + partialByteLength);\r\n\r\n    //     // block padding scheme\r\n    //     let padding = false; // NO_PADDING\r\n    //     const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\r\n\r\n    //     debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\r\n\r\n    //     if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\r\n    //         padding = true; // W3C_PADDING, also PKCS#7\r\n    //     }\r\n\r\n    //     // byte offset in first block of the cypher text that contains the range begin\r\n    //     const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\r\n\r\n    //     // we read the entire first block, even if partially used\r\n    //     const readPosition = partialByteBegin - blockOffset;\r\n\r\n    //     debug(\"LCP transformStream() blockOffset: \" + blockOffset);\r\n    //     debug(\"LCP transformStream() readPosition: \" + readPosition);\r\n\r\n    //     // number of blocks to read\r\n    //     let blocksCount = 1;\r\n    //     let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\r\n\r\n    //     debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\r\n\r\n    //     if (partialByteLength < bytesInFirstBlock) {\r\n    //         bytesInFirstBlock = 0;\r\n    //     }\r\n    //     if (bytesInFirstBlock > 0) {\r\n    //         blocksCount++;\r\n    //     }\r\n\r\n    //     const diff = partialByteLength - bytesInFirstBlock;\r\n\r\n    //     debug(\"LCP transformStream() diff: \" + diff);\r\n\r\n    //     let inc = diff / AES_BLOCK_SIZE;\r\n    //     debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n    //     inc = Math.floor(inc);\r\n    //     debug(\"LCP transformStream() inc: \" + inc);\r\n\r\n    //     blocksCount += inc;\r\n\r\n    //     const rem = diff % AES_BLOCK_SIZE;\r\n    //     debug(\"LCP transformStream() rem: \" + rem);\r\n\r\n    //     if (rem !== 0) {\r\n    //         blocksCount++;\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() blocksCount: \" + blocksCount);\r\n\r\n    //     // number of bytes to read (block aligned)\r\n    //     const toRead = blocksCount * AES_BLOCK_SIZE;\r\n\r\n    //     debug(\"LCP transformStream() toRead: \" + toRead);\r\n\r\n    //     const rangeStream = new RangeStream(readPosition, readPosition + toRead - 1, stream.length);\r\n    //     stream.stream.pipe(rangeStream);\r\n    //     let buff: Buffer;\r\n    //     try {\r\n    //         buff = await streamToBufferPromise(rangeStream);\r\n    //     } catch (err) {\r\n    //         debug(err);\r\n    //         return Promise.reject(\"OUCH!\");\r\n    //     }\r\n\r\n    //     debug(\"LCP transformStream() buff.length: \" + buff.length);\r\n\r\n    //     let newBuff = this.innerDecrypt(buff, padding);\r\n\r\n    //     debug(\"LCP transformStream() newBuff.length: \" + newBuff.length);\r\n\r\n    //     if (newBuff.length < partialByteLength) {\r\n    //         debug(\"newBuff.length < partialByteLength\");\r\n    //     }\r\n    //     newBuff = newBuff.slice(blockOffset);\r\n\r\n    //     debug(\"LCP transformStream() newBuff.length (blockOffset): \" + newBuff.length);\r\n\r\n    //     const bufferStream = bufferToStream(newBuff);\r\n\r\n    //     const sal: IStreamAndLength = {\r\n    //         length: plainTextSize, // newBuff.length,\r\n    //         reset: async () => {\r\n    //             const resetedStream = await stream.reset();\r\n    //             return this.transformStream(\r\n    //                 publication, link,\r\n    //                 resetedStream,\r\n    //                 isPartialByteRangeRequest,\r\n    //                 partialByteBegin, partialByteEnd);\r\n    //         },\r\n    //         stream: bufferStream,\r\n    //     };\r\n    //     return Promise.resolve(sal);\r\n    // }\r\n\r\n    // private async transformStream_(\r\n    //     publication: Publication, link: Link,\r\n    //     stream: IStreamAndLength,\r\n    //     isPartialByteRangeRequest: boolean,\r\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\r\n\r\n    //     debug(\"LCP transformStream_() RAW STREAM LENGTH: \" + stream.length);\r\n\r\n    //     let l = -1;\r\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\r\n    //         l = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\r\n    //     } else {\r\n    //         l = await this.getDecryptedSizeStream(publication, link, stream);\r\n    //         debug(\"LCP transformStream_() ---- getDecryptedSizeStream(): \" + l);\r\n    //         stream = await stream.reset();\r\n    //         // length cached to avoid resetting the stream to zero-position\r\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = l;\r\n    //     }\r\n\r\n    //     const data = await streamToBufferPromise(stream.stream);\r\n    //     debug(\"LCP transformStream_() RAW BUFFER LENGTH after reset: \" + stream.length);\r\n    //     const buff = await this.transformBuffer(publication, link, data);\r\n    //     debug(\"LCP transformStream_() DECRYPTED BUFFER LENGTH: \" + buff.length);\r\n\r\n    //     if (partialByteBegin < 0) {\r\n    //         partialByteBegin = 0;\r\n    //     }\r\n    //     if (partialByteEnd < 0) {\r\n    //         partialByteEnd = buff.length - 1;\r\n    //     }\r\n\r\n    //     if (isPartialByteRangeRequest) {\r\n    //         debug(\"LCP transformStream_() PARTIAL: \" + partialByteBegin + \" - \" + partialByteEnd);\r\n\r\n    //         const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, buff.length);\r\n    //         const bufferStream = bufferToStream(buff);\r\n    //         bufferStream.pipe(rangeStream);\r\n\r\n    //         const sal: IStreamAndLength = {\r\n    //             length: buff.length, // (partialByteEnd + 1) - partialByteBegin,\r\n    //             reset: async () => {\r\n    //                 const resetedStream = await stream.reset();\r\n    //                 return this.transformStream(\r\n    //                     publication, link,\r\n    //                     resetedStream,\r\n    //                     isPartialByteRangeRequest,\r\n    //                     partialByteBegin, partialByteEnd);\r\n    //             },\r\n    //             stream: rangeStream,\r\n    //         };\r\n    //         return Promise.resolve(sal);\r\n    //     } else {\r\n    //         debug(\"LCP transformStream_() WHOLE: \" + buff.length);\r\n\r\n    //         const sal: IStreamAndLength = {\r\n    //             length: buff.length,\r\n    //             reset: async () => {\r\n    //                 return Promise.resolve(sal);\r\n    //             },\r\n    //             stream: bufferToStream(buff),\r\n    //         };\r\n    //         return Promise.resolve(sal);\r\n    //     }\r\n    // }\r\n\r\n    // private async getDecryptedSizeBuffer(_publication: Publication, _link: Link, data: Buffer): Promise<number> {\r\n\r\n    //     const totalByteLength = data.length;\r\n\r\n    //     const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\r\n    //     if (totalByteLength < TWO_AES_BLOCK_SIZE) {\r\n    //         return 0;\r\n    //     }\r\n    //     const readPos = totalByteLength - TWO_AES_BLOCK_SIZE;\r\n\r\n    //     const buff = data.slice(readPos, totalByteLength);\r\n\r\n    //     return this.getDecryptedSizeBuffer_(totalByteLength, buff);\r\n    // }\r\n\r\n    protected innerDecrypt(\r\n        publication: Publication, _link: Link,\r\n        data: Buffer, padding: boolean): Buffer {\r\n        // debug(\"LCP innerDecrypt() data.length: \" + data.length);\r\n        // debug(\"LCP innerDecrypt() padding: \" + padding);\r\n\r\n        const contentKey = publication.LCP.ContentKey;\r\n\r\n        const buffIV = data.slice(0, AES_BLOCK_SIZE);\r\n        // debug(\"LCP innerDecrypt() buffIV.length: \" + buffIV.length);\r\n\r\n        // TODO: keep buffer to avoid costly string conversion?\r\n        const iv = buffIV.toString(\"binary\");\r\n\r\n        const buffToDecrypt = data.slice(AES_BLOCK_SIZE);\r\n        // debug(\"LCP innerDecrypt() buffToDecrypt: \" + buffToDecrypt.length);\r\n\r\n        // TODO: keep buffer to avoid costly string conversion?\r\n        const strToDecrypt = buffToDecrypt.toString(\"binary\");\r\n        const toDecrypt =\r\n            forge.util.createBuffer(strToDecrypt, \"binary\");\r\n\r\n        const aesCbcDecipher = (forge as any).cipher.createDecipher(\"AES-CBC\", contentKey);\r\n        aesCbcDecipher.start({ iv, additionalData_: \"binary-encoded string\" });\r\n        aesCbcDecipher.update(toDecrypt);\r\n\r\n        function unpadFunc() { return false; }\r\n        // const res =\r\n        aesCbcDecipher.finish(padding ? undefined : unpadFunc);\r\n        // debug(res);\r\n\r\n        const decryptedZipData = aesCbcDecipher.output.bytes();\r\n\r\n        // debug(forge.util.bytesToHex(decryptedZipData));\r\n        // debug(decryptedZipData.toHex());\r\n\r\n        const buff = new Buffer(decryptedZipData, \"binary\");\r\n\r\n        // debug(\"LCP innerDecrypt() buff.length: \" + buff.length);\r\n\r\n        return buff;\r\n    }\r\n\r\n    // protected async getDecryptedSizeBuffer_(totalByteLength: number, buff: Buffer): Promise<ICryptoInfo> {\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() totalByteLength: \" + totalByteLength);\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() buff.length: \" + buff.length);\r\n\r\n    //     const padding = true;\r\n    //     const newBuff = this.innerDecrypt(buff, padding);\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() newBuff.length (innerDecrypt): \" + newBuff.length);\r\n\r\n    //     // newBuff.length === 0\r\n    //     // when last second block is all padding,\r\n    //     // otherwise newBuff.length === overflow encrypted bytes,\r\n    //     // number between [1, AES_BLOCK_SIZE[\r\n    //     const nPaddingBytes = padding ? (AES_BLOCK_SIZE - newBuff.length) : newBuff[15];\r\n    //     // debugx(\"LCP getDecryptedSizeBuffer_() nPaddingBytes: \" + nPaddingBytes);\r\n\r\n    //     const size = totalByteLength - AES_BLOCK_SIZE - nPaddingBytes;\r\n\r\n    //     // debug(\"LCP getDecryptedSizeBuffer_() size: \" + size);\r\n\r\n    //     const res: ICryptoInfo = {\r\n    //         length: size,\r\n    //         padding: nPaddingBytes,\r\n    //     };\r\n\r\n    //     return Promise.resolve(res);\r\n    // }\r\n\r\n    // private async transformBuffer(_publication: Publication, link: Link, data: Buffer): Promise<Buffer> {\r\n\r\n    //     const l = await this.getDecryptedSizeBuffer(_publication, link, data);\r\n    //     debug(\"LCP transformBuffer() ==== decrypted buffer length CHECK: \" + l);\r\n\r\n    //     let transformedData = this.innerDecrypt(data, true);\r\n\r\n    //     debug(\"LCP transformBuffer() decrypted buffer length before INFLATE: \" + transformedData.length);\r\n\r\n    //     if (link.Properties.Encrypted.Compression === \"deflate\") {\r\n    //         transformedData = zlib.inflateRawSync(transformedData);\r\n    //     }\r\n\r\n    //     debug(\"LCP transformBuffer() decrypted buffer length after INFLATE: \" + transformedData.length);\r\n\r\n    //     if (link.Properties.Encrypted.OriginalLength\r\n    //         && link.Properties.Encrypted.OriginalLength !== transformedData.length) {\r\n    //         debug(`LENGTH NOT MATCH ${link.Properties.Encrypted.OriginalLength} !== ${transformedData.length}`);\r\n    //     }\r\n\r\n    //     return Promise.resolve(transformedData);\r\n    // }\r\n}\r\n"]}