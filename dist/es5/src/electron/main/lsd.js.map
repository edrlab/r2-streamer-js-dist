{"version":3,"file":"lsd.js","sourceRoot":"","sources":["../../../../../src/electron/main/lsd.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\n\nimport { streamToBufferPromise } from \"@r2-streamer-js/_utils/stream/BufferUtils\";\nimport { injectBufferInZip } from \"@r2-streamer-js/_utils/zip/zipInjector\";\nimport { Publication } from \"@r2-streamer-js/models/publication\";\nimport { LCP } from \"@r2-streamer-js/parser/epub/lcp\";\nimport * as debug_ from \"debug\";\nimport * as moment from \"moment\";\nimport * as request from \"request\";\nimport * as requestPromise from \"request-promise-native\";\nimport { JSON as TAJSON } from \"ta-json\";\n\nconst debug = debug_(\"r2:lsd\");\n\nexport interface IDeviceIDManager {\n    getDeviceNAME(): string;\n\n    getDeviceID(): string;\n\n    checkDeviceID(key: string): string;\n\n    recordDeviceID(key: string): void;\n}\n\nexport const deviceIDManager: IDeviceIDManager = {\n\n    checkDeviceID: (_key: string): string => {\n        return \"\";\n    },\n\n    getDeviceID: (): string => {\n        return \"\";\n    },\n\n    getDeviceNAME: (): string => {\n        return \"\";\n    },\n\n    recordDeviceID: (_key: string) => {\n        return;\n    },\n};\n\nexport async function launchStatusDocumentProcessing(\n    publication: Publication,\n    publicationPath: string,\n    _deviceIDManager: IDeviceIDManager,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    if (!publication.LCP || !publication.LCP.Links) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n    const linkStatus = publication.LCP.Links.find((link) => {\n        return link.Rel === \"status\";\n    });\n    if (!linkStatus) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n\n    debug(linkStatus);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            failure(\"HTTP CODE \" + response.statusCode);\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const responseStr = responseData.toString(\"utf8\");\n        debug(responseStr);\n        const responseJson = global.JSON.parse(responseStr);\n        debug(responseJson);\n\n        // debug(responseJson.id);\n        // debug(responseJson.status); // revoked, returned, cancelled, expired\n        // debug(responseJson.message);\n        // if (responseJson.updated) {\n        //     debug(responseJson.updated.license);\n        //     debug(responseJson.updated.status);\n        // }\n        // if (responseJson.links) {\n        //     responseJson.links.forEach((link: any) => {\n        //         debug(link.rel); // license, register, return, renew\n        //         debug(link.href);\n        //         debug(link.type);\n        //         debug(link.templated);\n        //         debug(link.title);\n        //         debug(link.profile);\n        //     });\n        // }\n        // if (responseJson.potential_rights) {\n        //     debug(responseJson.potential_rights.end);\n        // }\n        // if (responseJson.events) {\n        //     responseJson.events.forEach((event: any) => {\n        //         debug(event.type);\n        //         debug(event.name);\n        //         debug(event.timestamp); // ISO 8601 time and date\n        //         debug(event.id);\n        //     });\n        // }\n\n        if (responseJson.updated && responseJson.updated.license &&\n            (publication.LCP.Updated || publication.LCP.Issued)) {\n            const updatedLicenseLSD = moment(responseJson.updated.license);\n            const updatedLicense = moment(publication.LCP.Updated || publication.LCP.Issued);\n            const forceUpdate = false;\n            if (forceUpdate || updatedLicense.isBefore(updatedLicenseLSD)) {\n                debug(\"LSD license updating...\");\n                if (responseJson.links) {\n                    const licenseLink = responseJson.links.find((link: any) => {\n                        return link.rel === \"license\";\n                    });\n                    if (!licenseLink) {\n                        debug(\"LSD license link is missing.\");\n                        onStatusDocumentProcessingComplete();\n                        return;\n                    }\n                    await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                        licenseLink.href, onStatusDocumentProcessingComplete);\n                    return;\n                }\n            }\n        }\n        onStatusDocumentProcessingComplete();\n\n        // private void registerDevice(final DoneCallback doneCallback_registerDevice) {\n\n        //             String deviceID = m_deviceIDManager.getDeviceID();\n        //             String deviceNAME = m_deviceIDManager.getDeviceNAME();\n\n        //             boolean doRegister = false;\n        //             if (m_statusDocument_LINK_REGISTER == null) {\n        //                 doRegister = false;\n        //             } else if (m_statusDocument_STATUS.equals(\"ready\")) {\n        //                 doRegister = true;\n        //             } else if (m_statusDocument_STATUS.equals(\"active\")) {\n\n        //                 String deviceIDForStatusDoc = m_deviceIDManager.checkDeviceID(m_statusDocument_ID);\n\n        //                 if (deviceIDForStatusDoc == null) {\n        //                     doRegister = true;\n        //                 } else if (!deviceIDForStatusDoc.equals(deviceID)) {\n        // // this should really never happen ... but let's ensure anyway.\n        //                     doRegister = true;\n        //                 }\n        //             }\n\n        //             if (!doRegister) {\n        //                 doneCallback_registerDevice.Done(false);\n        //                 return;\n        //             }\n        //             String url = m_statusDocument_LINK_REGISTER.m_href;\n        //             if (m_statusDocument_LINK_REGISTER.m_templated.equals(\"true\")) {\n\n        //     // URLEncoder.encode() doesn't generate %20 for space character (instead: '+')\n        //     // So we use android.net.Uri's appendQueryParameter() instead (see below)\n        //     //        try {\n        //     //            deviceID = URLEncoder.encode(deviceID, \"UTF-8\");\n        //     //            deviceNAME = URLEncoder.encode(deviceNAME, \"UTF-8\");\n        //     //        } catch (Exception ex) {\n        //     //            // noop\n        //     //        }\n        //     //        url = url.replace(\"{?id,name}\", \"?id=\" + deviceID + \"&name=\" + deviceNAME);\n\n        //                 url = url.replace(\"{?id,name}\", \"\"); // TODO: smarter regexp?\n        //                 url = Uri.parse(url).buildUpon()\n        //                         .appendQueryParameter(\"id\", deviceID)\n        //                         .appendQueryParameter(\"name\", deviceNAME)\n        //                         .build().toString();\n        //             }\n\n        //             Locale currentLocale = getCurrentLocale();\n        //             String langCode = currentLocale.toString().replace('_', '-');\n        //             langCode = langCode + \",en-US;q=0.7,en;q=0.5\";\n\n        //             Future<Response<InputStream>> request = Ion.with(m_context)\n        //                     .load(\"POST\", url)\n        //                     .setLogging(\"Readium Ion\", Log.VERBOSE)\n\n        //                     //.setTimeout(AsyncHttpRequest.DEFAULT_TIMEOUT) //30000\n        //                     .setTimeout(6000)\n\n        //                     // TODO: comment this in production! (this is only for testing a local HTTP server)\n        //                     //.setHeader(\"X-Add-Delay\", \"2s\")\n\n        //                     // LCP / LSD server with message localization\n        //                     .setHeader(\"Accept-Language\", langCode)\n\n        //     // QUERY params (templated URI)\n        //     //                        .setBodyParameter(\"id\", dID)\n        //     //                        .setBodyParameter(\"name\", dNAME)\n\n        //                     .asInputStream()\n        //                     .withResponse()\n\n        //                     // UI thread\n        //                     .setCallback(new FutureCallback<Response<InputStream>>() {\n        //                         @Override\n        //                         public void onCompleted(Exception e, Response<InputStream> response) {\n\n        //                             InputStream inputStream = response != null ? response.getResult() : null;\n        //                             int httpResponseCode = response != null ? response.getHeaders().code() : 0;\n        //                             if (e != null || inputStream == null\n        //                                     || httpResponseCode < 200 || httpResponseCode >= 300) {\n\n        //                                 doneCallback_registerDevice.Done(false);\n        //                                 return;\n        //                             }\n\n        //                             try {\n\n        //                                 StringWriter writer = new StringWriter();\n        //                                 IOUtils.copy(inputStream, writer, \"UTF-8\");\n        //                                 String json = writer.toString().trim();\n\n        //                                 boolean okay = parseStatusDocumentJson(json);\n\n        //                                 if (okay && m_statusDocument_STATUS.equals(\"active\")) {\n        //                                     m_deviceIDManager.recordDeviceID(m_statusDocument_ID);\n        //                                 }\n\n        //                                 doneCallback_registerDevice.Done(true);\n\n        //                             } catch (Exception ex) {\n        //                                 ex.printStackTrace();\n        //                                 doneCallback_registerDevice.Done(false);\n        //                             } finally {\n        //                                 try {\n        //                                     inputStream.close();\n        //                                 } catch (IOException ex) {\n        //                                     ex.printStackTrace();\n        //                                     // ignore\n        //                                 }\n        //                             }\n        //                         }\n        //                     });\n        //         }\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: linkStatus.Href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: linkStatus.Href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n\nasync function fetchAndInjectUpdatedLicense(\n    publication: Publication,\n    publicationPath: string,\n    href: string,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    debug(\"OLD LCP LICENSE, FETCHING LSD UPDATE ... \" + href);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            if (href.indexOf(\"/licenses/\") > 0) {\n                const newHref = href.replace(\"/licenses/\", \"/api/v1/purchases/license/\");\n                debug(\"TRYING AGAIN: \" + newHref);\n                await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                    newHref, onStatusDocumentProcessingComplete);\n            } else {\n                failure(\"HTTP CODE \" + response.statusCode);\n            }\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const lcplStr = responseData.toString(\"utf8\");\n        debug(lcplStr);\n\n        const zipEntryPath = \"META-INF/license.lcpl\";\n\n        let lcpl: LCP | undefined;\n        try {\n            const lcplJson = global.JSON.parse(lcplStr);\n            debug(lcplJson);\n            lcpl = TAJSON.deserialize<LCP>(lcplJson, LCP);\n        } catch (erorz) {\n            debug(erorz);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!lcpl) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        lcpl.ZipPath = zipEntryPath;\n        lcpl.JsonSource = lcplStr;\n        lcpl.init();\n        publication.LCP = lcpl;\n        // publication.AddLink(\"application/vnd.readium.lcp.license-1.0+json\", [\"license\"],\n        //     lcpl.ZipPath, false);\n\n        const newPublicationPath = publicationPath + \".new\";\n        injectBufferInZip(publicationPath, newPublicationPath, responseData, zipEntryPath,\n            (err) => {\n                debug(err);\n                onStatusDocumentProcessingComplete();\n            },\n            () => {\n                debug(\"EPUB license.lcpl injected.\");\n\n                setTimeout(() => {\n                    fs.unlinkSync(publicationPath);\n                    setTimeout(() => {\n                        fs.renameSync(newPublicationPath, publicationPath);\n                        onStatusDocumentProcessingComplete();\n                    }, 500);\n                }, 500);\n            });\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n"]}