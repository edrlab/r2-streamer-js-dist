{"version":3,"file":"lsd.js","sourceRoot":"","sources":["../../../../src/electron/lsd.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\n\nimport { streamToBufferPromise } from \"@r2-streamer-js/_utils/stream/BufferUtils\";\nimport { injectBufferInZip } from \"@r2-streamer-js/_utils/zip/zipInjector\";\nimport { Publication } from \"@r2-streamer-js/models/publication\";\nimport { LCP } from \"@r2-streamer-js/parser/epub/lcp\";\nimport * as debug_ from \"debug\";\nimport * as moment from \"moment\";\nimport * as request from \"request\";\nimport * as requestPromise from \"request-promise-native\";\nimport { JSON as TAJSON } from \"ta-json\";\n\nconst debug = debug_(\"r2:lsd\");\n\nexport interface IDeviceIDManager {\n    getDeviceNAME(): string;\n\n    getDeviceID(): string;\n\n    checkDeviceID(key: string): string;\n\n    recordDeviceID(key: string): void;\n}\n\nexport async function launchStatusDocumentProcessing(\n    publication: Publication,\n    publicationPath: string,\n    _deviceIDManager: IDeviceIDManager,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    if (!publication.LCP || !publication.LCP.Links) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n    const linkStatus = publication.LCP.Links.find((link) => {\n        return link.Rel === \"status\";\n    });\n    if (!linkStatus) {\n        if (onStatusDocumentProcessingComplete) {\n            onStatusDocumentProcessingComplete();\n        }\n        return;\n    }\n\n    debug(linkStatus);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            failure(\"HTTP CODE \" + response.statusCode);\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const responseStr = responseData.toString(\"utf8\");\n        debug(responseStr);\n        const responseJson = global.JSON.parse(responseStr);\n        debug(responseJson);\n\n        // debug(responseJson.id);\n        // debug(responseJson.status); // revoked, returned, cancelled, expired\n        // debug(responseJson.message);\n        // if (responseJson.updated) {\n        //     debug(responseJson.updated.license);\n        //     debug(responseJson.updated.status);\n        // }\n        // if (responseJson.links) {\n        //     responseJson.links.forEach((link: any) => {\n        //         debug(link.rel); // license, register, return, renew\n        //         debug(link.href);\n        //         debug(link.type);\n        //         debug(link.templated);\n        //         debug(link.title);\n        //         debug(link.profile);\n        //     });\n        // }\n        // if (responseJson.potential_rights) {\n        //     debug(responseJson.potential_rights.end);\n        // }\n        // if (responseJson.events) {\n        //     responseJson.events.forEach((event: any) => {\n        //         debug(event.type);\n        //         debug(event.name);\n        //         debug(event.timestamp); // ISO 8601 time and date\n        //         debug(event.id);\n        //     });\n        // }\n\n        if (responseJson.updated && responseJson.updated.license &&\n            (publication.LCP.Updated || publication.LCP.Issued)) {\n            const updatedLicenseLSD = moment(responseJson.updated.license);\n            const updatedLicense = moment(publication.LCP.Updated || publication.LCP.Issued);\n            const forceUpdate = false;\n            if (forceUpdate || updatedLicense.isBefore(updatedLicenseLSD)) {\n                debug(\"LSD license updating...\");\n                if (responseJson.links) {\n                    const licenseLink = responseJson.links.find((link: any) => {\n                        return link.rel === \"license\";\n                    });\n                    if (!licenseLink) {\n                        debug(\"LSD license link is missing.\");\n                        onStatusDocumentProcessingComplete();\n                        return;\n                    }\n                    await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                        licenseLink.href, onStatusDocumentProcessingComplete);\n                    return;\n                }\n            }\n        }\n        onStatusDocumentProcessingComplete();\n\n        // private void registerDevice(final DoneCallback doneCallback_registerDevice) {\n\n        //             String deviceID = m_deviceIDManager.getDeviceID();\n        //             String deviceNAME = m_deviceIDManager.getDeviceNAME();\n\n        //             boolean doRegister = false;\n        //             if (m_statusDocument_LINK_REGISTER == null) {\n        //                 doRegister = false;\n        //             } else if (m_statusDocument_STATUS.equals(\"ready\")) {\n        //                 doRegister = true;\n        //             } else if (m_statusDocument_STATUS.equals(\"active\")) {\n\n        //                 String deviceIDForStatusDoc = m_deviceIDManager.checkDeviceID(m_statusDocument_ID);\n\n        //                 if (deviceIDForStatusDoc == null) {\n        //                     doRegister = true;\n        //                 } else if (!deviceIDForStatusDoc.equals(deviceID)) {\n            // // this should really never happen ... but let's ensure anyway.\n        //                     doRegister = true;\n        //                 }\n        //             }\n\n        //             if (!doRegister) {\n        //                 doneCallback_registerDevice.Done(false);\n        //                 return;\n        //             }\n        //             String url = m_statusDocument_LINK_REGISTER.m_href;\n        //             if (m_statusDocument_LINK_REGISTER.m_templated.equals(\"true\")) {\n\n        //     // URLEncoder.encode() doesn't generate %20 for space character (instead: '+')\n        //     // So we use android.net.Uri's appendQueryParameter() instead (see below)\n        //     //        try {\n        //     //            deviceID = URLEncoder.encode(deviceID, \"UTF-8\");\n        //     //            deviceNAME = URLEncoder.encode(deviceNAME, \"UTF-8\");\n        //     //        } catch (Exception ex) {\n        //     //            // noop\n        //     //        }\n        //     //        url = url.replace(\"{?id,name}\", \"?id=\" + deviceID + \"&name=\" + deviceNAME);\n\n        //                 url = url.replace(\"{?id,name}\", \"\"); // TODO: smarter regexp?\n        //                 url = Uri.parse(url).buildUpon()\n        //                         .appendQueryParameter(\"id\", deviceID)\n        //                         .appendQueryParameter(\"name\", deviceNAME)\n        //                         .build().toString();\n        //             }\n\n        //             Locale currentLocale = getCurrentLocale();\n        //             String langCode = currentLocale.toString().replace('_', '-');\n        //             langCode = langCode + \",en-US;q=0.7,en;q=0.5\";\n\n        //             Future<Response<InputStream>> request = Ion.with(m_context)\n        //                     .load(\"POST\", url)\n        //                     .setLogging(\"Readium Ion\", Log.VERBOSE)\n\n        //                     //.setTimeout(AsyncHttpRequest.DEFAULT_TIMEOUT) //30000\n        //                     .setTimeout(6000)\n\n        //                     // TODO: comment this in production! (this is only for testing a local HTTP server)\n        //                     //.setHeader(\"X-Add-Delay\", \"2s\")\n\n        //                     // LCP / LSD server with message localization\n        //                     .setHeader(\"Accept-Language\", langCode)\n\n        //     // QUERY params (templated URI)\n        //     //                        .setBodyParameter(\"id\", dID)\n        //     //                        .setBodyParameter(\"name\", dNAME)\n\n        //                     .asInputStream()\n        //                     .withResponse()\n\n        //                     // UI thread\n        //                     .setCallback(new FutureCallback<Response<InputStream>>() {\n        //                         @Override\n        //                         public void onCompleted(Exception e, Response<InputStream> response) {\n\n        //                             InputStream inputStream = response != null ? response.getResult() : null;\n        //                             int httpResponseCode = response != null ? response.getHeaders().code() : 0;\n        //                             if (e != null || inputStream == null\n        //                                     || httpResponseCode < 200 || httpResponseCode >= 300) {\n\n        //                                 doneCallback_registerDevice.Done(false);\n        //                                 return;\n        //                             }\n\n        //                             try {\n\n        //                                 StringWriter writer = new StringWriter();\n        //                                 IOUtils.copy(inputStream, writer, \"UTF-8\");\n        //                                 String json = writer.toString().trim();\n\n        //                                 boolean okay = parseStatusDocumentJson(json);\n\n        //                                 if (okay && m_statusDocument_STATUS.equals(\"active\")) {\n        //                                     m_deviceIDManager.recordDeviceID(m_statusDocument_ID);\n        //                                 }\n\n        //                                 doneCallback_registerDevice.Done(true);\n\n        //                             } catch (Exception ex) {\n        //                                 ex.printStackTrace();\n        //                                 doneCallback_registerDevice.Done(false);\n        //                             } finally {\n        //                                 try {\n        //                                     inputStream.close();\n        //                                 } catch (IOException ex) {\n        //                                     ex.printStackTrace();\n        //                                     // ignore\n        //                                 }\n        //                             }\n        //                         }\n        //                     });\n        //         }\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: linkStatus.Href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: linkStatus.Href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n\nasync function fetchAndInjectUpdatedLicense(\n    publication: Publication,\n    publicationPath: string,\n    href: string,\n    onStatusDocumentProcessingComplete: () => void) {\n\n    debug(\"OLD LCP LICENSE, FETCHING LSD UPDATE ... \" + href);\n\n    const failure = (err: any) => {\n        debug(err);\n        onStatusDocumentProcessingComplete();\n    };\n\n    const success = async (response: request.RequestResponse) => {\n        if (response.statusCode && (response.statusCode < 200 || response.statusCode >= 300)) {\n            if (href.indexOf(\"/licenses/\") > 0) {\n                const newHref = href.replace(\"/licenses/\", \"/api/v1/purchases/license/\");\n                debug(\"TRYING AGAIN: \" + newHref);\n                await fetchAndInjectUpdatedLicense(publication, publicationPath,\n                        newHref, onStatusDocumentProcessingComplete);\n            } else {\n                failure(\"HTTP CODE \" + response.statusCode);\n            }\n            return;\n        }\n\n        let responseData: Buffer | undefined;\n        try {\n            responseData = await streamToBufferPromise(response);\n        } catch (err) {\n            debug(err);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!responseData) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        const lcplStr = responseData.toString(\"utf8\");\n        debug(lcplStr);\n\n        const zipEntryPath = \"META-INF/license.lcpl\";\n\n        let lcpl: LCP | undefined;\n        try {\n            const lcplJson = global.JSON.parse(lcplStr);\n            debug(lcplJson);\n            lcpl = TAJSON.deserialize<LCP>(lcplJson, LCP);\n        } catch (erorz) {\n            debug(erorz);\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        if (!lcpl) {\n            onStatusDocumentProcessingComplete();\n            return;\n        }\n        lcpl.ZipPath = zipEntryPath;\n        lcpl.JsonSource = lcplStr;\n        lcpl.init();\n        publication.LCP = lcpl;\n        // publication.AddLink(\"application/vnd.readium.lcp.license-1.0+json\", [\"license\"],\n        //     lcpl.ZipPath, false);\n\n        const newPublicationPath = publicationPath + \".new\";\n        injectBufferInZip(publicationPath, newPublicationPath, responseData, zipEntryPath,\n            (err) => {\n                debug(err);\n                onStatusDocumentProcessingComplete();\n            },\n            () => {\n                debug(\"EPUB license.lcpl injected.\");\n\n                setTimeout(() => {\n                    fs.unlinkSync(publicationPath);\n                    setTimeout(() => {\n                        fs.renameSync(newPublicationPath, publicationPath);\n                        onStatusDocumentProcessingComplete();\n                    }, 500);\n                }, 500);\n            });\n    };\n\n    const headers = {\n        \"Accept-Language\": \"en-UK,en-US;q=0.7,en;q=0.5\",\n    };\n\n    // No response streaming! :(\n    // https://github.com/request/request-promise/issues/90\n    const needsStreamingResponse = true;\n    if (needsStreamingResponse) {\n        request.get({\n            headers,\n            method: \"GET\",\n            uri: href,\n        })\n            .on(\"response\", success)\n            .on(\"error\", failure);\n    } else {\n        let response: requestPromise.FullResponse | undefined;\n        try {\n            // tslint:disable-next-line:await-promise no-floating-promises\n            response = await requestPromise({\n                headers,\n                method: \"GET\",\n                resolveWithFullResponse: true,\n                uri: href,\n            });\n        } catch (err) {\n            failure(err);\n            return;\n        }\n\n        // To please the TypeScript compiler :(\n        response = response as requestPromise.FullResponse;\n        await success(response);\n    }\n}\n"]}