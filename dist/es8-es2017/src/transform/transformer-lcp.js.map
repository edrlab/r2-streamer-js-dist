{"version":3,"file":"transformer-lcp.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp.ts"],"names":[],"mappings":"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","sourcesContent":["import * as crypto from \"crypto\";\nimport * as zlib from \"zlib\";\n\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { RangeStream } from \"@utils/stream/RangeStream\";\nimport { IStreamAndLength } from \"@utils/zip/zip\";\nimport * as debug_ from \"debug\";\n\nimport { ITransformer } from \"./transformer\";\n\n// import * as forge from \"node-forge\";\nimport { bufferToStream, streamToBufferPromise } from \"@utils/stream/BufferUtils\";\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\n// import { Transform } from \"stream\";\n\nconst debug = debug_(\"r2:transformer:lcp\");\n// const debugx = debug_(\"r2:transformer:stream:lcp\");\n\nconst AES_BLOCK_SIZE = 16;\n\n// let streamCounter = 0;\n\nconst readStream = async (s: NodeJS.ReadableStream, n: number): Promise<Buffer> => {\n    return new Promise<Buffer>((resolve, reject) => {\n        // s.pause();\n        const onReadable = () => {\n            // debug(\"readStream READABLE\");\n            const b = s.read(n);\n            s.removeListener(\"readable\", onReadable);\n            s.removeListener(\"error\", reject);\n            // s.resume();\n            resolve(b as Buffer);\n        };\n        s.on(\"readable\", onReadable);\n        s.on(\"error\", reject);\n        // s.on(\"end\", () => {\n        //     debug(\"readStream END\");\n        // });\n        // s.on(\"drain\", () => {\n        //     debug(\"readStream DRAIN\");\n        // });\n        // s.on(\"finish\", () => {\n        //     debug(\"readStream FINISH\");\n        // });\n    });\n};\n\nexport interface ICryptoInfo {\n    length: number;\n    padding: number;\n}\n\nexport class TransformerLCP implements ITransformer {\n\n    public supports(publication: Publication, link: Link): boolean {\n\n        if (!publication.LCP) {\n            return false;\n        }\n\n        if (!publication.LCP.isReady()) {\n            debug(\"LCP not ready!\");\n            return false;\n        }\n\n        const check = link.Properties.Encrypted.Scheme === \"http://readium.org/2014/01/lcp\"\n            && (link.Properties.Encrypted.Profile === \"http://readium.org/lcp/basic-profile\" ||\n                link.Properties.Encrypted.Profile === \"http://readium.org/lcp/profile-1.0\")\n            && link.Properties.Encrypted.Algorithm === \"http://www.w3.org/2001/04/xmlenc#aes256-cbc\"\n            ;\n        if (!check) {\n            debug(\"Incorrect resource LCP fields.\");\n            debug(link.Properties.Encrypted.Scheme);\n            debug(link.Properties.Encrypted.Profile);\n            debug(link.Properties.Encrypted.Algorithm);\n            return false;\n        }\n\n        return true;\n    }\n\n    public async transformStream(\n        publication: Publication,\n        link: Link,\n        stream: IStreamAndLength,\n        isPartialByteRangeRequest: boolean,\n        partialByteBegin: number,\n        partialByteEnd: number): Promise<IStreamAndLength> {\n\n        let plainTextSize = -1;\n\n        let nativelyDecryptedStream: NodeJS.ReadableStream | undefined;\n        if (publication.LCP.isNativeNodePlugin()) {\n\n            debug(\"DECRYPT: \" + link.Href);\n\n            let fullEncryptedBuffer: Buffer;\n            try {\n                fullEncryptedBuffer = await streamToBufferPromise(stream.stream);\n            } catch (err) {\n                debug(err);\n                return Promise.reject(\"OUCH!\");\n            }\n\n            // debug(fullEncryptedBuffer.length);\n\n            // debug(fullEncryptedBuffer.slice(0, 32));\n\n            // debug(fullEncryptedBuffer.slice(fullEncryptedBuffer.length - 32));\n\n            let nativelyDecryptedBuffer: Buffer;\n            try {\n                nativelyDecryptedBuffer = await publication.LCP.decrypt(fullEncryptedBuffer);\n            } catch (err) {\n                debug(err);\n                return Promise.reject(\"OUCH!\");\n            }\n\n            // debug(nativelyDecryptedBuffer.length);\n\n            plainTextSize = nativelyDecryptedBuffer.length;\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n\n            if (link.Properties.Encrypted.OriginalLength &&\n                link.Properties.Encrypted.Compression === \"none\" &&\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\n\n                debug(`############### ` +\n                    `LCP transformStream() LENGTH NOT MATCH ` +\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize: ` +\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\n            }\n\n            nativelyDecryptedStream = bufferToStream(nativelyDecryptedBuffer);\n        } else {\n            let cryptoInfo: ICryptoInfo | undefined;\n            let cypherBlockPadding = -1;\n            if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n                plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n                cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\n            } else {\n                // const timeBegin = process.hrtime();\n                try {\n                    cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\n                } catch (err) {\n                    debug(err);\n                    return Promise.reject(err);\n                }\n                plainTextSize = cryptoInfo.length;\n                cypherBlockPadding = cryptoInfo.padding;\n\n                // length cached to avoid resetting the stream to zero-position\n                link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n                link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\n\n                try {\n                    stream = await stream.reset();\n                } catch (err) {\n                    debug(err);\n                    return Promise.reject(err);\n                }\n\n                // const timeElapsed = process.hrtime(timeBegin);\n                // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\n                //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\n\n                // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n\n                if (link.Properties.Encrypted.OriginalLength &&\n                    link.Properties.Encrypted.Compression === \"none\" &&\n                    link.Properties.Encrypted.OriginalLength !== plainTextSize) {\n\n                    debug(`############### ` +\n                        `LCP transformStream() LENGTH NOT MATCH ` +\n                        `link.Properties.Encrypted.OriginalLength !== plainTextSize: ` +\n                        `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\n                }\n            }\n        }\n\n        if (partialByteBegin < 0) {\n            partialByteBegin = 0;\n        }\n\n        if (partialByteEnd < 0) {\n            partialByteEnd = plainTextSize - 1;\n            if (link.Properties.Encrypted.OriginalLength) {\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\n            }\n        }\n\n        let destStream: NodeJS.ReadableStream;\n        if (nativelyDecryptedStream) {\n            destStream = nativelyDecryptedStream;\n        } else {\n            // const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n            let rawDecryptStream: NodeJS.ReadableStream | undefined;\n\n            let ivBuffer: Buffer | undefined;\n            if (link.Properties.Encrypted.CypherBlockIV) {\n                ivBuffer = Buffer.from(link.Properties.Encrypted.CypherBlockIV, \"binary\");\n\n                const cypherRangeStream = new RangeStream(AES_BLOCK_SIZE, stream.length - 1, stream.length);\n                stream.stream.pipe(cypherRangeStream);\n                rawDecryptStream = cypherRangeStream;\n            } else {\n                // const ivRangeStream = new RangeStream(0, AES_BLOCK_SIZE - 1, stream.length);\n                // stream.stream.pipe(ivRangeStream);\n                // try {\n                //     ivBuffer = await streamToBufferPromise(ivRangeStream);\n                // } catch (err) {\n                //     debug(err);\n                //     return Promise.reject(\"OUCH!\");\n                // }\n                // try {\n                //     stream = await stream.reset();\n                // } catch (err) {\n                //     debug(err);\n                //     return Promise.reject(err);\n                // }\n\n                // debug(\"D1\");\n                // debug(ivBuffer.length);\n                // debug(ivBuffer.toString(\"hex\"));\n\n                // ivBuffer = stream.stream.read(AES_BLOCK_SIZE) as Buffer;\n\n                try {\n                    ivBuffer = await readStream(stream.stream, AES_BLOCK_SIZE);\n                } catch (err) {\n                    debug(err);\n                    return Promise.reject(err);\n                }\n\n                // debug(\"D2\");\n                // debug(ivBuffer.length);\n                // debug(ivBuffer.toString(\"hex\"));\n                // b06ca4cec8831eb158f1a317503f5101\n                // === asharedculture_soundtrack.mp3\n                //\n                // 07e6870e5d708f39e98316b5c0a574c5\n                // === shared-culture.mp4\n\n                link.Properties.Encrypted.CypherBlockIV = ivBuffer.toString(\"binary\");\n\n                stream.stream.resume();\n                rawDecryptStream = stream.stream;\n            }\n            // debug(\"IV: \" + forge.util.bytesToHex(ivBuffer));\n\n            // debug(forge.util.bytesToHex(contentKey as string));\n\n            // https://github.com/nodejs/node/blob/master/lib/crypto.js#L259\n            const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\n                publication.LCP.ContentKey, // new Buffer(contentKey as string, \"binary\"),\n                ivBuffer);\n            decryptStream.setAutoPadding(false);\n            rawDecryptStream.pipe(decryptStream);\n\n            destStream = decryptStream;\n\n            if (link.Properties.Encrypted.CypherBlockPadding) {\n                // debugx(\"cryptoInfo.padding: \" + cypherBlockPadding);\n                const cypherUnpaddedStream = new RangeStream(0, plainTextSize - 1, plainTextSize);\n                destStream.pipe(cypherUnpaddedStream);\n                destStream = cypherUnpaddedStream;\n            }\n\n            // const counterStream2 = new CounterPassThroughStream(++streamCounter);\n            // destStream.pipe(counterStream2)\n            //     .on(\"progress\", function f() {\n            //         // debug(\"Crypto PROGRESS: \" +\n            //         //     (this as CounterPassThroughStream).id +\n            //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n            //     })\n            //     .on(\"end\", function f() {\n            //         debug(\"Crypto END: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"close\", function f() {\n            //         debug(\"Crypto CLOSE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .once(\"finish\", function f() {\n            //         debug(\"Crypto FINISH: \" +\n            //             (this as CounterPassThroughStream).id +\n            //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n\n            //         if (plainTextSize !==\n            //             (this as CounterPassThroughStream).bytesReceived) {\n\n            //             debug(`############### ` +\n            //                 `LCP Crypto LENGTH NOT MATCH ` +\n            //                 `plainTextSize !== bytesReceived:` +\n            //                 `${plainTextSize} !== ` +\n            //                 `${(this as CounterPassThroughStream).bytesReceived}`);\n            //         }\n            //     })\n            //     .on(\"error\", function f() {\n            //         debug(\"CounterPassThroughStream ERROR: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"pipe\", function f() {\n            //         debug(\"CounterPassThroughStream PIPE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"unpipe\", function f() {\n            //         debug(\"CounterPassThroughStream UNPIPE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"drain\", function f() {\n            //         // debug(\"CounterPassThroughStream DRAIN: \" +\n            //         //     (this as CounterPassThroughStream).id);\n            //     });\n            // destStream = counterStream2;\n        }\n\n        if (link.Properties.Encrypted.Compression === \"deflate\") {\n\n            // https://github.com/nodejs/node/blob/master/lib/zlib.js\n            const inflateStream = zlib.createInflateRaw();\n            destStream.pipe(inflateStream);\n            destStream = inflateStream;\n\n            // const counterStream = new CounterPassThroughStream(++streamCounter);\n            // inflateStream.pipe(counterStream)\n            //     .on(\"progress\", function f() {\n            //         // debug(\"CounterPassThroughStream PROGRESS: \" +\n            //         //     (this as CounterPassThroughStream).id +\n            //         //     \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n            //     })\n            //     .on(\"end\", function f() {\n            //         debug(\"CounterPassThroughStream END: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"close\", function f() {\n            //         debug(\"CounterPassThroughStream CLOSE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .once(\"finish\", function f() {\n            //         debug(\"CounterPassThroughStream FINISH: \" +\n            //             (this as CounterPassThroughStream).id +\n            //             \" -- \" + (this as CounterPassThroughStream).bytesReceived);\n\n            //         if (link.Properties.Encrypted.OriginalLength &&\n            //             link.Properties.Encrypted.OriginalLength !==\n            //             (this as CounterPassThroughStream).bytesReceived) {\n\n            //             debug(`############### ` +\n            //                 `LCP zlib.createInflateRaw LENGTH NOT MATCH ` +\n            //                 `link.Properties.Encrypted.OriginalLength !== bytesReceived:` +\n            //                 `${link.Properties.Encrypted.OriginalLength} !== ` +\n            //                 `${(this as CounterPassThroughStream).bytesReceived}`);\n            //         }\n            //     })\n            //     .on(\"error\", function f() {\n            //         debug(\"CounterPassThroughStream ERROR: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"pipe\", function f() {\n            //         debug(\"CounterPassThroughStream PIPE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"unpipe\", function f() {\n            //         debug(\"CounterPassThroughStream UNPIPE: \" +\n            //             (this as CounterPassThroughStream).id);\n            //     })\n            //     .on(\"drain\", function f() {\n            //         // debug(\"CounterPassThroughStream DRAIN: \" +\n            //         //     (this as CounterPassThroughStream).id);\n            //     });\n            // destStream = counterStream;\n        }\n\n        const l = link.Properties.Encrypted.OriginalLength ?\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\n\n        if (isPartialByteRangeRequest) {\n            const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, l);\n            destStream.pipe(rangeStream);\n            destStream = rangeStream;\n            // l = partialByteLength;\n        }\n\n        const sal: IStreamAndLength = {\n            length: l,\n            reset: async () => {\n\n                let resetedStream: IStreamAndLength;\n                try {\n                    resetedStream = await stream.reset();\n                } catch (err) {\n                    debug(err);\n                    return Promise.reject(err);\n                }\n                if (!resetedStream) {\n                    return Promise.reject(\"??\");\n                }\n\n                return this.transformStream(\n                    publication, link,\n                    resetedStream,\n                    isPartialByteRangeRequest,\n                    partialByteBegin, partialByteEnd);\n            },\n            stream: destStream,\n        };\n        return Promise.resolve(sal);\n    }\n\n    protected async getDecryptedSizeStream(\n        publication: Publication, _link: Link,\n        stream: IStreamAndLength): Promise<ICryptoInfo> {\n\n        return new Promise<ICryptoInfo>((resolve, reject) => {\n\n            // debug(\"LCP getDecryptedSizeStream() stream.length: \" + stream.length);\n\n            // debug(\"LCP getDecryptedSizeStream() AES_BLOCK_SIZE: \" + AES_BLOCK_SIZE);\n\n            // CipherText = IV + PlainText + BLOCK - (PlainText MOD BLOCK)\n            // overflow: (PlainText MOD BLOCK) === PlainText - (floor(PlainText / BLOCK) * BLOCK)\n            // thus: CipherText = IV + BLOCK * (floor(PlainText / BLOCK) + 1)\n\n            // IV = AES_BLOCK_SIZE (first block in cyphertext)\n            // + at least one block\n            // (last one in cyphertext is either full 16-bytes random W3C padding\n            // in case plaintext is exactly multiple of block size,\n            // or partial cypher + padding)\n            const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n            if (stream.length < TWO_AES_BLOCK_SIZE) {\n                reject(\"crypto err\");\n                return;\n            }\n            const readPos = stream.length - TWO_AES_BLOCK_SIZE;\n\n            const cypherRangeStream = new RangeStream(readPos, readPos + TWO_AES_BLOCK_SIZE - 1, stream.length);\n            stream.stream.pipe(cypherRangeStream);\n\n            // let buff: Buffer;\n            // try {\n            //     buff = await streamToBufferPromise(cypherRangeStream);\n            // } catch (err) {\n            //     debug(err);\n            //     reject(\"crypto err\");\n            //     return;\n            // }\n\n            // // debug(\"LCP getDecryptedSizeStream() buff.length: \" + buff.length);\n\n            // // // debug(buff.toString(\"hex\"));\n            // // for (let i = 0; i < buff.length; i++) {\n            // //     const b = buff[i];\n            // //     if (i === AES_BLOCK_SIZE) {\n            // //         debug(\"____\");\n            // //     }\n            // //     debug(b);\n            // // }\n\n            // resolve(this.getDecryptedSizeBuffer_(stream.length, buff));\n\n            const decrypteds: Buffer[] = [];\n\n            cypherRangeStream.on(\"readable\", () => {\n                // debug(\"readable\");\n\n                const ivBuffer = cypherRangeStream.read(AES_BLOCK_SIZE);\n                if (!ivBuffer) {\n                    // debug(\"readable null (end)\");\n                    return;\n                }\n\n                // debug(ivBuffer.toString(\"hex\"));\n                // e10cb2a27aa7b9633f104ccca113d499\n                // === asharedculture_soundtrack.mp3\n                //\n                // 5d290cb97ea83ccc01a67d30a9c7eeaa\n                // === shared-culture.mp4\n\n                const encrypted = cypherRangeStream.read(AES_BLOCK_SIZE);\n                // debug(encrypted.toString(\"hex\"));\n                // 14b46cb1e279d51c12ce13989b3d6cf3\n                // === asharedculture_soundtrack.mp3\n                //\n                // b2924b9b0cd64ab7cd349beef8e4b068\n                // === shared-culture.mp4\n\n                const decryptStream = crypto.createDecipheriv(\"aes-256-cbc\",\n                    publication.LCP.ContentKey, // new Buffer(contentKey as string, \"binary\"),\n                    ivBuffer);\n                decryptStream.setAutoPadding(false);\n\n                const buff1 = decryptStream.update(encrypted);\n                // debug(buff1.toString(\"hex\"));\n                // ecf8848cb3c0c97b9e159ec2daa96810\n                // === asharedculture_soundtrack.mp3\n                //\n                // 004c61766635332e31372e308b6f7004\n                // === shared-culture.mp4\n                if (buff1) {\n                    decrypteds.push(buff1);\n                }\n\n                const buff2 = decryptStream.final();\n                // debug(buff2.toString(\"hex\"));\n                if (buff2) {\n                    decrypteds.push(buff2);\n                }\n            });\n\n            cypherRangeStream.on(\"end\", () => {\n                // debug(\"end\");\n\n                const decrypted = Buffer.concat(decrypteds);\n                // debug(decrypted.toString(\"hex\"));\n                // debug(decrypted.length);\n\n                const nPaddingBytes = decrypted[AES_BLOCK_SIZE - 1]; // decrypted.length = 1\n                // debug(nPaddingBytes);\n\n                const size = stream.length - AES_BLOCK_SIZE - nPaddingBytes;\n\n                const res: ICryptoInfo = {\n                    length: size,\n                    padding: nPaddingBytes,\n                };\n                resolve(res);\n            });\n\n            cypherRangeStream.on(\"error\", () => {\n                reject(\"DECRYPT err\");\n            });\n        });\n    }\n}\n\n    // cc-shared-culture/EPUB/audio/asharedculture_soundtrack.mp3\n    // 3265152 bytes\n    // 3 MB\n    // 204072 * 16 BLOCKS (inc IV)\n    // 3265152 MOD 16 = 0\n    // IV 16\n    // PAD 16, full extra block (random)\n    // + 32 = 3265184 total cypher-text\n\n    // cc-shared-culture/EPUB/video/shared-culture.mp4\n    // 21784780 bytes\n    // 21 MB\n    // 1361548.75 * 16 BLOCKS (inc IV)\n    // 21784780 MOD 16 = 12 (0.75 * 16)\n    // IV 16\n    // PAD 4 (12 cypher-text bytes in last block)\n    // + 20 = 21784800 total cypher-text\n\n    // cc-shared-culture/EPUB/video/shared-culture.webm\n    // 8330669 bytes\n    // 8 MB\n    // 520666.8125 * 16 BLOCKS (inc IV)\n    // 8330669 MOD 16 = 13 (0.8125 * 16)\n    // IV 16\n    // PAD 3 (13 cypher-text bytes in last block)\n    // + 19 = 8330688 total cypher-text\n"]}