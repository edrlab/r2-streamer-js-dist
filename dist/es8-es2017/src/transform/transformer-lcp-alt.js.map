{"version":3,"file":"transformer-lcp-alt.js","sourceRoot":"","sources":["../../../../src/transform/transformer-lcp-alt.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transform } from \"stream\";\n\nimport { Publication } from \"@models/publication\";\nimport { Link } from \"@models/publication-link\";\nimport { IStreamAndLength } from \"@utils/zip/zip\";\nimport * as debug_ from \"debug\";\nimport * as forge from \"node-forge\";\n\nimport { ICryptoInfo, TransformerLCP } from \"./transformer-lcp\";\n\n// import { CounterPassThroughStream } from \"@utils/stream/CounterPassThroughStream\";\n\n// import * as forge from \"node-forge\";\n// import { streamToBufferPromise } from \"@utils/stream/BufferUtils\";\n// import { RangeStream } from \"@utils/stream/RangeStream\";\n// import { ITransformer } from \"./transformer\";\n\nconst debug = debug_(\"r2:transformer:lcp\");\nconst debugx = debug_(\"r2:transformer:stream:lcp\");\n\nconst AES_BLOCK_SIZE = 16;\n\n// let streamCounter = 0;\n\nexport class TransformerLCPAlt extends TransformerLCP {\n\n    public async transformStream(\n        publication: Publication,\n        link: Link,\n        stream: IStreamAndLength,\n        isPartialByteRangeRequest: boolean,\n        partialByteBegin: number,\n        partialByteEnd: number): Promise<IStreamAndLength> {\n\n        let cryptoInfo: ICryptoInfo | undefined;\n        let plainTextSize = -1;\n        let cypherBlockPadding = -1;\n        if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n            plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n            cypherBlockPadding = link.Properties.Encrypted.CypherBlockPadding;\n        } else {\n            // const timeBegin = process.hrtime();\n\n            cryptoInfo = await this.getDecryptedSizeStream(publication, link, stream);\n            plainTextSize = cryptoInfo.length;\n            cypherBlockPadding = cryptoInfo.padding;\n\n            // length cached to avoid resetting the stream to zero-position\n            link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n            link.Properties.Encrypted.CypherBlockPadding = cypherBlockPadding;\n\n            stream = await stream.reset();\n\n            // const timeElapsed = process.hrtime(timeBegin);\n            // debug(`LCP transformStream() ---- getDecryptedSizeStream():` +\n            //     `${timeElapsed[0]} seconds + ${timeElapsed[1]} nanoseconds`);\n\n            // debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n\n            if (link.Properties.Encrypted.OriginalLength &&\n                link.Properties.Encrypted.Compression === \"none\" &&\n                link.Properties.Encrypted.OriginalLength !== plainTextSize) {\n\n                debug(`############### ` +\n                    `LCP transformStream() LENGTH NOT MATCH ` +\n                    `link.Properties.Encrypted.OriginalLength !== plainTextSize:` +\n                    `${link.Properties.Encrypted.OriginalLength} !== ${plainTextSize}`);\n            }\n        }\n\n        if (partialByteBegin < 0) {\n            partialByteBegin = 0;\n        }\n\n        if (partialByteEnd < 0) {\n            partialByteEnd = plainTextSize - 1;\n            if (link.Properties.Encrypted.OriginalLength) {\n                partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\n            }\n        }\n\n        const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n        // block padding scheme\n        let padding = false; // NO_PADDING\n        const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\n\n        // debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\n\n        if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\n            padding = true; // W3C_PADDING, also PKCS#7\n        }\n\n        // byte offset in first block of the cypher text that contains the range begin\n        const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\n\n        // we read the entire first block, even if partially used\n        const readPosition = partialByteBegin - blockOffset;\n\n        // debug(\"LCP transformStream() blockOffset: \" + blockOffset);\n        // debug(\"LCP transformStream() readPosition: \" + readPosition);\n\n        // number of blocks to read\n        let blocksCount = 1;\n        let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\n\n        // debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\n\n        if (partialByteLength < bytesInFirstBlock) {\n            bytesInFirstBlock = 0;\n        }\n        if (bytesInFirstBlock > 0) {\n            blocksCount++;\n        }\n\n        const diff = partialByteLength - bytesInFirstBlock;\n\n        // debug(\"LCP transformStream() diff: \" + diff);\n\n        let inc = diff / AES_BLOCK_SIZE;\n        // debug(\"LCP transformStream() inc: \" + inc);\n\n        inc = Math.floor(inc);\n        // debug(\"LCP transformStream() inc: \" + inc);\n\n        blocksCount += inc;\n\n        const rem = diff % AES_BLOCK_SIZE;\n        // debug(\"LCP transformStream() rem: \" + rem);\n\n        if (rem !== 0) {\n            blocksCount++;\n        }\n\n        // debug(\"LCP transformStream() blocksCount: \" + blocksCount);\n\n        // number of bytes to read (block aligned)\n        const toRead = blocksCount * AES_BLOCK_SIZE;\n\n        const readPositionEND = readPosition + toRead - 1;\n\n        // const rangeStream = new RangeStream(readPosition, readPositionEND, stream.length);\n        const decryptStreamStreamBegin = readPosition;\n        const decryptStreamStreamEnd = readPositionEND;\n\n        const decryptStreamBlockOffset = blockOffset;\n\n        let decryptStreamBytesReceived = 0;\n        let decryptStreamBytesSent = 0;\n        let decryptStreamFinished = false;\n        let decryptStreamClosed = false;\n        let decryptStreamFirst = true;\n\n        const decryptStreamThis = this;\n\n        let decryptStreamBuffers: Buffer[] = [];\n\n        const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n\n        // @ts-ignore: TS2345 strictFunctionTypes\n        const decryptStream = new Transform({\n            flush(callback: () => void): void {\n                debugx(\"LcpDecryptStream FLUSH\");\n\n                let toDecrypt: Buffer | undefined;\n\n                let decryptStreamBuffersTotalLength = 0;\n                decryptStreamBuffers.forEach((buff) => {\n                    decryptStreamBuffersTotalLength += buff.length;\n                });\n                if (decryptStreamBuffersTotalLength) {\n\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBuffersTotalLength: \" +\n                        decryptStreamBuffersTotalLength);\n\n                    const available = decryptStreamBuffersTotalLength;\n\n                    if (available === TWO_AES_BLOCK_SIZE) {\n                        toDecrypt = Buffer.concat(decryptStreamBuffers);\n                        decryptStreamBuffers = [];\n                    } else if (available < TWO_AES_BLOCK_SIZE) {\n                        debugx(\"LcpDecryptStream NOT ENOUGH DATA????\");\n                    } else { // available > TWO_AES_BLOCK_SIZE\n\n                        const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\n                        decryptStreamBuffers = [];\n\n                        const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\n                        const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                        // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\n                        if (blocksBytes === decryptStreamBuffersConcat.length) {\n                            toDecrypt = decryptStreamBuffersConcat;\n                        } else {\n                            debugx(\"LcpDecryptStream OVERFLOW DATA????\");\n                            // toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\n                            // decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\n                        }\n                    }\n                }\n\n                if (toDecrypt) {\n                    let newBuff = decryptStreamThis.innerDecrypt(\n                        publication,\n                        link,\n                        toDecrypt,\n                        padding);\n                    if (decryptStreamFirst) {\n                        decryptStreamFirst = false;\n                        newBuff = newBuff.slice(decryptStreamBlockOffset);\n                    }\n                    decryptStreamBytesSent += newBuff.length;\n                    debugx(\"LcpDecryptStream FLUSH decryptStreamBytesSent: \" + decryptStreamBytesSent);\n                    decryptStream.push(newBuff);\n                }\n\n                if (decryptStreamBytesSent !== plainTextSize) {\n\n                    debugx(`############### ` +\n                        `LcpDecryptStream FLUSH  LENGTH NOT MATCH ` +\n                        `decryptStreamBytesSent !== plainTextSize:` +\n                        `[ ${decryptStreamStreamBegin} (${decryptStreamStreamEnd}) ] ` +\n                        `${decryptStreamBytesReceived} (${stream.length}) > ` +\n                        `${decryptStreamBytesSent} !== ${plainTextSize}`);\n                }\n                callback();\n            },\n\n            transform(chunk: Buffer, _encoding: string, callback: () => void): void {\n                decryptStreamBytesReceived += chunk.length;\n\n                debugx(\"TRANSFORM chunk.length: \" + chunk.length + \" (( \" + decryptStreamBytesReceived);\n\n                if (decryptStreamFinished) {\n                    if (!decryptStreamClosed) {\n                        debugx(\"???? LcpDecryptStream CLOSING...\");\n                        decryptStreamClosed = true;\n                        decryptStream.push(null);\n                    } else {\n                        debugx(\"???? LcpDecryptStream STILL PIPE CALLING _transform ??!\");\n                        decryptStream.end();\n                    }\n                } else {\n                    if (decryptStreamBytesReceived > decryptStreamStreamBegin) {\n\n                        let chunkBegin = 0;\n                        let chunkEnd = chunk.length - 1;\n\n                        chunkBegin = decryptStreamStreamBegin - (decryptStreamBytesReceived - chunk.length);\n                        if (chunkBegin < 0) {\n                            chunkBegin = 0;\n                        }\n\n                        if (decryptStreamBytesReceived > decryptStreamStreamEnd) {\n                            decryptStreamFinished = true;\n\n                            const decr = decryptStreamBytesReceived - decryptStreamStreamEnd;\n\n                            debugx(\"LcpDecryptStream TRANSFORM FINISH decr: \" + decr);\n\n                            chunkEnd = chunk.length - decr;\n                        }\n\n                        debugx(`CHUNK: ${chunkBegin}-${chunkEnd}/${chunk.length}`);\n\n                        const encryptedChunk = chunk.slice(chunkBegin, chunkEnd + 1);\n\n                        let toDecrypt: Buffer | undefined;\n\n                        let decryptStreamBuffersTotalLength = 0;\n                        decryptStreamBuffers.forEach((buff) => {\n                            decryptStreamBuffersTotalLength += buff.length;\n                        });\n                        if (decryptStreamBuffersTotalLength) {\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBuffersTotalLength: \" +\n                                decryptStreamBuffersTotalLength);\n\n                            const available = decryptStreamBuffersTotalLength + encryptedChunk.length;\n\n                            if (available === TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                                toDecrypt = Buffer.concat(decryptStreamBuffers);\n                                decryptStreamBuffers = [];\n                            } else if (available < TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                            } else { // available > TWO_AES_BLOCK_SIZE\n                                decryptStreamBuffers.push(encryptedChunk);\n                                const decryptStreamBuffersConcat = Buffer.concat(decryptStreamBuffers);\n                                decryptStreamBuffers = [];\n\n                                const nBlocks = Math.floor(decryptStreamBuffersConcat.length / AES_BLOCK_SIZE);\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                                // decryptStreamBuffersConcat.length % AES_BLOCK_SIZE === 0\n                                if (blocksBytes === decryptStreamBuffersConcat.length) {\n                                    toDecrypt = decryptStreamBuffersConcat;\n                                } else {\n                                    toDecrypt = decryptStreamBuffersConcat.slice(0, blocksBytes);\n                                    decryptStreamBuffers.push(decryptStreamBuffersConcat.slice(blocksBytes));\n                                }\n                            }\n                        } else {\n                            if (encryptedChunk.length === TWO_AES_BLOCK_SIZE) {\n                                toDecrypt = encryptedChunk;\n                            } else if (encryptedChunk.length < TWO_AES_BLOCK_SIZE) {\n                                decryptStreamBuffers.push(encryptedChunk);\n                            } else { // encryptedChunk.length > TWO_AES_BLOCK_SIZE\n                                const nBlocks = Math.floor(encryptedChunk.length / AES_BLOCK_SIZE);\n                                const blocksBytes = nBlocks * AES_BLOCK_SIZE;\n\n                                // encryptedChunk.length % AES_BLOCK_SIZE === 0\n                                if (blocksBytes === encryptedChunk.length) {\n                                    toDecrypt = encryptedChunk;\n                                } else {\n                                    toDecrypt = encryptedChunk.slice(0, blocksBytes);\n                                    decryptStreamBuffers.push(encryptedChunk.slice(blocksBytes));\n                                }\n                            }\n                        }\n\n                        if (toDecrypt) {\n\n                            debugx(`CHUNK TO DECRYPT: ${toDecrypt.length}`);\n\n                            let newBuff = decryptStreamThis.innerDecrypt(\n                                publication,\n                                link,\n                                toDecrypt,\n                                decryptStreamFinished ? padding : false);\n\n                            debugx(`CHUNK DECRYPTED: ${newBuff.length}`);\n\n                            if (decryptStreamFirst) {\n                                decryptStreamFirst = false;\n                                debugx(\"LcpDecryptStream TRANSFORM decryptStreamBlockOffset: \" +\n                                    decryptStreamBlockOffset);\n                                newBuff = newBuff.slice(decryptStreamBlockOffset);\n                            }\n                            decryptStreamBytesSent += newBuff.length;\n                            debugx(\"LcpDecryptStream TRANSFORM decryptStreamBytesSent: \" + decryptStreamBytesSent);\n                            decryptStream.push(newBuff);\n                        }\n\n                        if (decryptStreamFinished) {\n                            debugx(\"LcpDecryptStream FINISHING...\");\n                            decryptStreamClosed = true;\n                            decryptStream.push(null);\n                            decryptStream.end();\n                        }\n                    } else {\n                        // NOOP\n                        // no call to this.push(), we skip the entire current chunk buffer\n                    }\n                }\n\n                callback();\n            },\n        });\n\n        const l = link.Properties.Encrypted.OriginalLength ?\n            link.Properties.Encrypted.OriginalLength : plainTextSize;\n\n        const sal: IStreamAndLength = {\n            length: l,\n            reset: async () => {\n                const resetedStream = await stream.reset();\n                return this.transformStream(\n                    publication, link,\n                    resetedStream,\n                    isPartialByteRangeRequest,\n                    partialByteBegin, partialByteEnd);\n            },\n            stream: decryptStream,\n        };\n        return Promise.resolve(sal);\n    }\n\n    // private async transformStream__(\n    //     publication: Publication, link: Link,\n    //     stream: IStreamAndLength,\n    //     isPartialByteRangeRequest: boolean,\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\n\n    //     if (!isPartialByteRangeRequest) {\n    //         return this.transformStream_(\n    //             publication, link,\n    //             stream,\n    //             isPartialByteRangeRequest,\n    //             partialByteBegin, partialByteEnd);\n    //     }\n\n    //     debug(\"LCP transformStream() RAW STREAM LENGTH: \" + stream.length);\n\n    //     let plainTextSize = -1;\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n    //         plainTextSize = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n    //     } else {\n    //         plainTextSize = await this.getDecryptedSizeStream(publication, link, stream);\n    //         debug(\"LCP transformStream() ---- getDecryptedSizeStream(): \" + plainTextSize);\n    //         stream = await stream.reset();\n    //         // length cached to avoid resetting the stream to zero-position\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = plainTextSize;\n    //     }\n    //     debug(\"LCP transformStream() plainTextSize: \" + plainTextSize);\n\n    //     if (partialByteBegin < 0) {\n    //         partialByteBegin = 0;\n    //     }\n\n    //     if (partialByteEnd < 0) {\n    //         partialByteEnd = plainTextSize - 1;\n    //         if (link.Properties.Encrypted.OriginalLength) {\n    //             partialByteEnd = link.Properties.Encrypted.OriginalLength - 1;\n    //         }\n    //     }\n\n    //     const partialByteLength = (partialByteEnd + 1) - partialByteBegin;\n\n    //     debug(\"LCP transformStream() partialByteBegin: \" + partialByteBegin);\n    //     debug(\"LCP transformStream() partialByteEnd: \" + partialByteEnd);\n    //     debug(\"LCP transformStream() partialByteLength: \" + partialByteLength);\n\n    //     // block padding scheme\n    //     let padding = false; // NO_PADDING\n    //     const sizeWithoutPaddedBlock = plainTextSize - (plainTextSize % AES_BLOCK_SIZE);\n\n    //     debug(\"LCP transformStream() sizeWithoutPaddedBlock: \" + sizeWithoutPaddedBlock);\n\n    //     if ((partialByteEnd + 1) > sizeWithoutPaddedBlock) {\n    //         padding = true; // W3C_PADDING, also PKCS#7\n    //     }\n\n    //     // byte offset in first block of the cypher text that contains the range begin\n    //     const blockOffset = partialByteBegin % AES_BLOCK_SIZE;\n\n    //     // we read the entire first block, even if partially used\n    //     const readPosition = partialByteBegin - blockOffset;\n\n    //     debug(\"LCP transformStream() blockOffset: \" + blockOffset);\n    //     debug(\"LCP transformStream() readPosition: \" + readPosition);\n\n    //     // number of blocks to read\n    //     let blocksCount = 1;\n    //     let bytesInFirstBlock = (AES_BLOCK_SIZE - blockOffset) % AES_BLOCK_SIZE;\n\n    //     debug(\"LCP transformStream() bytesInFirstBlock: \" + bytesInFirstBlock);\n\n    //     if (partialByteLength < bytesInFirstBlock) {\n    //         bytesInFirstBlock = 0;\n    //     }\n    //     if (bytesInFirstBlock > 0) {\n    //         blocksCount++;\n    //     }\n\n    //     const diff = partialByteLength - bytesInFirstBlock;\n\n    //     debug(\"LCP transformStream() diff: \" + diff);\n\n    //     let inc = diff / AES_BLOCK_SIZE;\n    //     debug(\"LCP transformStream() inc: \" + inc);\n\n    //     inc = Math.floor(inc);\n    //     debug(\"LCP transformStream() inc: \" + inc);\n\n    //     blocksCount += inc;\n\n    //     const rem = diff % AES_BLOCK_SIZE;\n    //     debug(\"LCP transformStream() rem: \" + rem);\n\n    //     if (rem !== 0) {\n    //         blocksCount++;\n    //     }\n\n    //     debug(\"LCP transformStream() blocksCount: \" + blocksCount);\n\n    //     // number of bytes to read (block aligned)\n    //     const toRead = blocksCount * AES_BLOCK_SIZE;\n\n    //     debug(\"LCP transformStream() toRead: \" + toRead);\n\n    //     const rangeStream = new RangeStream(readPosition, readPosition + toRead - 1, stream.length);\n    //     stream.stream.pipe(rangeStream);\n    //     let buff: Buffer;\n    //     try {\n    //         buff = await streamToBufferPromise(rangeStream);\n    //     } catch (err) {\n    //         debug(err);\n    //         return Promise.reject(\"OUCH!\");\n    //     }\n\n    //     debug(\"LCP transformStream() buff.length: \" + buff.length);\n\n    //     let newBuff = this.innerDecrypt(buff, padding);\n\n    //     debug(\"LCP transformStream() newBuff.length: \" + newBuff.length);\n\n    //     if (newBuff.length < partialByteLength) {\n    //         debug(\"newBuff.length < partialByteLength\");\n    //     }\n    //     newBuff = newBuff.slice(blockOffset);\n\n    //     debug(\"LCP transformStream() newBuff.length (blockOffset): \" + newBuff.length);\n\n    //     const bufferStream = bufferToStream(newBuff);\n\n    //     const sal: IStreamAndLength = {\n    //         length: plainTextSize, // newBuff.length,\n    //         reset: async () => {\n    //             const resetedStream = await stream.reset();\n    //             return this.transformStream(\n    //                 publication, link,\n    //                 resetedStream,\n    //                 isPartialByteRangeRequest,\n    //                 partialByteBegin, partialByteEnd);\n    //         },\n    //         stream: bufferStream,\n    //     };\n    //     return Promise.resolve(sal);\n    // }\n\n    // private async transformStream_(\n    //     publication: Publication, link: Link,\n    //     stream: IStreamAndLength,\n    //     isPartialByteRangeRequest: boolean,\n    //     partialByteBegin: number, partialByteEnd: number): Promise<IStreamAndLength> {\n\n    //     debug(\"LCP transformStream_() RAW STREAM LENGTH: \" + stream.length);\n\n    //     let l = -1;\n    //     if (link.Properties.Encrypted.DecryptedLengthBeforeInflate > 0) {\n    //         l = link.Properties.Encrypted.DecryptedLengthBeforeInflate;\n    //     } else {\n    //         l = await this.getDecryptedSizeStream(publication, link, stream);\n    //         debug(\"LCP transformStream_() ---- getDecryptedSizeStream(): \" + l);\n    //         stream = await stream.reset();\n    //         // length cached to avoid resetting the stream to zero-position\n    //         link.Properties.Encrypted.DecryptedLengthBeforeInflate = l;\n    //     }\n\n    //     const data = await streamToBufferPromise(stream.stream);\n    //     debug(\"LCP transformStream_() RAW BUFFER LENGTH after reset: \" + stream.length);\n    //     const buff = await this.transformBuffer(publication, link, data);\n    //     debug(\"LCP transformStream_() DECRYPTED BUFFER LENGTH: \" + buff.length);\n\n    //     if (partialByteBegin < 0) {\n    //         partialByteBegin = 0;\n    //     }\n    //     if (partialByteEnd < 0) {\n    //         partialByteEnd = buff.length - 1;\n    //     }\n\n    //     if (isPartialByteRangeRequest) {\n    //         debug(\"LCP transformStream_() PARTIAL: \" + partialByteBegin + \" - \" + partialByteEnd);\n\n    //         const rangeStream = new RangeStream(partialByteBegin, partialByteEnd, buff.length);\n    //         const bufferStream = bufferToStream(buff);\n    //         bufferStream.pipe(rangeStream);\n\n    //         const sal: IStreamAndLength = {\n    //             length: buff.length, // (partialByteEnd + 1) - partialByteBegin,\n    //             reset: async () => {\n    //                 const resetedStream = await stream.reset();\n    //                 return this.transformStream(\n    //                     publication, link,\n    //                     resetedStream,\n    //                     isPartialByteRangeRequest,\n    //                     partialByteBegin, partialByteEnd);\n    //             },\n    //             stream: rangeStream,\n    //         };\n    //         return Promise.resolve(sal);\n    //     } else {\n    //         debug(\"LCP transformStream_() WHOLE: \" + buff.length);\n\n    //         const sal: IStreamAndLength = {\n    //             length: buff.length,\n    //             reset: async () => {\n    //                 return Promise.resolve(sal);\n    //             },\n    //             stream: bufferToStream(buff),\n    //         };\n    //         return Promise.resolve(sal);\n    //     }\n    // }\n\n    // private async getDecryptedSizeBuffer(_publication: Publication, _link: Link, data: Buffer): Promise<number> {\n\n    //     const totalByteLength = data.length;\n\n    //     const TWO_AES_BLOCK_SIZE = 2 * AES_BLOCK_SIZE;\n    //     if (totalByteLength < TWO_AES_BLOCK_SIZE) {\n    //         return 0;\n    //     }\n    //     const readPos = totalByteLength - TWO_AES_BLOCK_SIZE;\n\n    //     const buff = data.slice(readPos, totalByteLength);\n\n    //     return this.getDecryptedSizeBuffer_(totalByteLength, buff);\n    // }\n\n    protected innerDecrypt(\n        publication: Publication, _link: Link,\n        data: Buffer, padding: boolean): Buffer {\n        // debug(\"LCP innerDecrypt() data.length: \" + data.length);\n        // debug(\"LCP innerDecrypt() padding: \" + padding);\n\n        const contentKey = publication.LCP.ContentKey;\n\n        const buffIV = data.slice(0, AES_BLOCK_SIZE);\n        // debug(\"LCP innerDecrypt() buffIV.length: \" + buffIV.length);\n\n        // TODO: keep buffer to avoid costly string conversion?\n        const iv = buffIV.toString(\"binary\");\n\n        const buffToDecrypt = data.slice(AES_BLOCK_SIZE);\n        // debug(\"LCP innerDecrypt() buffToDecrypt: \" + buffToDecrypt.length);\n\n        // TODO: keep buffer to avoid costly string conversion?\n        const strToDecrypt = buffToDecrypt.toString(\"binary\");\n        const toDecrypt =\n            forge.util.createBuffer(strToDecrypt, \"binary\");\n\n        const aesCbcDecipher = (forge as any).cipher.createDecipher(\"AES-CBC\", contentKey);\n        aesCbcDecipher.start({ iv, additionalData_: \"binary-encoded string\" });\n        aesCbcDecipher.update(toDecrypt);\n\n        function unpadFunc() { return false; }\n        // const res =\n        aesCbcDecipher.finish(padding ? undefined : unpadFunc);\n        // debug(res);\n\n        const decryptedZipData = aesCbcDecipher.output.bytes();\n\n        // debug(forge.util.bytesToHex(decryptedZipData));\n        // debug(decryptedZipData.toHex());\n\n        const buff = new Buffer(decryptedZipData, \"binary\");\n\n        // debug(\"LCP innerDecrypt() buff.length: \" + buff.length);\n\n        return buff;\n    }\n\n    // protected async getDecryptedSizeBuffer_(totalByteLength: number, buff: Buffer): Promise<ICryptoInfo> {\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() totalByteLength: \" + totalByteLength);\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() buff.length: \" + buff.length);\n\n    //     const padding = true;\n    //     const newBuff = this.innerDecrypt(buff, padding);\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() newBuff.length (innerDecrypt): \" + newBuff.length);\n\n    //     // newBuff.length === 0\n    //     // when last second block is all padding,\n    //     // otherwise newBuff.length === overflow encrypted bytes,\n    //     // number between [1, AES_BLOCK_SIZE[\n    //     const nPaddingBytes = padding ? (AES_BLOCK_SIZE - newBuff.length) : newBuff[15];\n    //     // debugx(\"LCP getDecryptedSizeBuffer_() nPaddingBytes: \" + nPaddingBytes);\n\n    //     const size = totalByteLength - AES_BLOCK_SIZE - nPaddingBytes;\n\n    //     // debug(\"LCP getDecryptedSizeBuffer_() size: \" + size);\n\n    //     const res: ICryptoInfo = {\n    //         length: size,\n    //         padding: nPaddingBytes,\n    //     };\n\n    //     return Promise.resolve(res);\n    // }\n\n    // private async transformBuffer(_publication: Publication, link: Link, data: Buffer): Promise<Buffer> {\n\n    //     const l = await this.getDecryptedSizeBuffer(_publication, link, data);\n    //     debug(\"LCP transformBuffer() ==== decrypted buffer length CHECK: \" + l);\n\n    //     let transformedData = this.innerDecrypt(data, true);\n\n    //     debug(\"LCP transformBuffer() decrypted buffer length before INFLATE: \" + transformedData.length);\n\n    //     if (link.Properties.Encrypted.Compression === \"deflate\") {\n    //         transformedData = zlib.inflateRawSync(transformedData);\n    //     }\n\n    //     debug(\"LCP transformBuffer() decrypted buffer length after INFLATE: \" + transformedData.length);\n\n    //     if (link.Properties.Encrypted.OriginalLength\n    //         && link.Properties.Encrypted.OriginalLength !== transformedData.length) {\n    //         debug(`LENGTH NOT MATCH ${link.Properties.Encrypted.OriginalLength} !== ${transformedData.length}`);\n    //     }\n\n    //     return Promise.resolve(transformedData);\n    // }\n}\n"]}